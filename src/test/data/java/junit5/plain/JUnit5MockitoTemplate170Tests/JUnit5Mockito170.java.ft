## Quick Settings - configure common code style and other settings here. -----------------------------------------------
## Set these to use special prefixes for test class members containing dependencies of certain types.
## Note that the template code below will ignore any prefix set to "" and use your IDE code style settings instead.
#set($dependencyMemberNamePrefix = "")
#set($mockDependencyMemberNamePrefix = "mock")
## Set this to use a special prefix for local fields containing arguments for test methods.
#set($parameterLocalFieldNamePrefix = "")
#set($mockParameterLocalFieldNamePrefix = "mock")
## Customize the name of the member and local field (if needed) used to store the instance of the source class.
#set($sourceClass.testClassMemberName = "${sourceClass.testClassMemberName}UnderTest")
#set($sourceClass.testClassLocalFieldName = "${sourceClass.testClassLocalFieldName}UnderTest")
#set($shouldUseMockitoExtension = $ClassUtils.isInTestClasspath('org.mockito.junit.jupiter.MockitoExtension'))
#set($shouldUseMockitoBdd = false)
## Configure how Bean DTOs are initialized.
#set($minNumberOfSettersToCall = 15)
#set($maxNumberOfSettersToCall = 70)
#set($useStaticImportForInitMocks = true)
## Set this to use mocks for mockable method parameters that end in "listener" or "callback" ignoring case.
#set($useMocksForListenerAndCallbackParameters = true)
#set($generateStubsAndVerifyStatements = true)
## Use this to specify custom initialization values for dependencies and method parameters of certain types;
## See https://squaretest.com#template_api_quick_settings for details.
#set($initExpressionOverrides = {} )
##----------------------------------------------------------------------------------------------------------------------

## Initialize the data model. This sets global variables based on the architype of the source class and Quick Settings.
## See the comments above the macro or https://squaretest.com#template_api_initializeTemplateDataModel for details.
#initializeTemplateDataModel()

## Package declaration
#if($StringUtils.isNotEmpty($sourceClass.packageName))
package $sourceClass.packageName;
#end

## Imports; Note that Squaretest invokes IntelliJ's import organize and code reformatter after creating the test class.
#foreach($importLine in $importLinesRequired)
    $importLine
#end
#if($shouldUseMockitoExtension)
import org.mockito.junit.jupiter.MockitoExtension;
#end
#if($useStaticImportForInitMocks)
import static org.mockito.MockitoAnnotations.$initMocksMethodName;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
#end
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
#renderImportsForMatchers()
#if($shouldUseMockitoBdd)
import static org.mockito.BDDMockito.willAnswer;
import static org.mockito.BDDMockito.willReturn;
import static org.mockito.BDDMockito.willThrow;
import static org.mockito.BDDMockito.then;
import static org.mockito.BDDMockito.given;
#else
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
#end
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.InjectMocks;
import org.mockito.stubbing.Answer;

## Test class
#if($mocksNeeded && $shouldUseMockitoExtension)
@ExtendWith(MockitoExtension.class)
#end
class ${sourceClass.name}Test {

## Declare member fields for the dependencies.
#renderMemberDeclarations($mockMemberFields)
#renderMemberDeclarations($nonMockMemberFields)

## Declare a member field for the instance of the source class.
#if($sourceClassMemberNeeded)
    #if($shouldUseInjectMocks) @InjectMocks #end
    private ${sourceClass.type.canonicalText} ${sourceClass.testClassMemberName};
#end

#if($mocksNeeded && !$shouldUseMockitoExtension && $hasOpenMocksMethod)
    private AutoCloseable mockitoCloseable;
#end

## Render setUp() only if we need to instantiate source class.
#if($sourceClassMemberNeeded && !($shouldUseInjectMocks && $shouldUseMockitoExtension))
@BeforeEach
void setUp() throws Exception {
    #if($mocksNeeded && !$shouldUseMockitoExtension)
        #set($initMocksQualifier = "#if(!$useStaticImportForInitMocks)MockitoAnnotations.#else#end")
        #if($hasOpenMocksMethod)
            mockitoCloseable = ${initMocksQualifier}${initMocksMethodName}(this);
        #else
            ${initMocksQualifier}${initMocksMethodName}(this);
        #end
    #end
    ## Initialize the non-mock member fields.
    #foreach($field in $nonMockMemberFields)
        $field.testClassMemberName = $field.initExpression;
    #end
    ## Initialize the member containing the source class.
    #if($shouldUseInjectMocks) ## Do nothing.
    #elseif($sourceClass.preferredConstructor)
        ## Invoke the constructor.
        ${sourceClass.testClassMemberName} = new #methodCall($sourceClass.preferredConstructor, true) #if($sourceClass.abstract && !$sourceClass.sealed)$sourceClass.abstractClassBody#end;
        #if($shouldSetPackageLocalFields)
            #foreach($field in $dependencies)
                ${sourceClass.testClassMemberName}.${field.declaredName} = #if($field.shouldStoreInReference) $field.testClassMemberName #else $field.initExpression #end;
            #end
        #end
    #elseif($sourceClass.singleton)
        ${sourceClass.testClassMemberName} = $sourceClass.singletonAccessExpression;
    #else
        ## As a fallback, set the member to null and leave a comment.
        ${sourceClass.testClassMemberName} = null /* TODO: construct the instance */;
    #end
}
#if($mocksNeeded && !$shouldUseMockitoExtension && $hasOpenMocksMethod)
@AfterEach
void tearDown() throws Exception {
    mockitoCloseable.close();
}
#end
#end
## Render the test methods.
#if($shouldCreateTestsForInstanceMethods)
    #renderTestMethods($sourceClass.instanceMethods.filterOut('private'))
#end
#renderTestMethods($sourceClass.staticMethods.filterOut('private'))
}

## Macros
## Add your own macros here. Newlines between macros will not appear in the generated test class;
## Squaretest automatically removes all but 1 newline at the end of the generated test class.

##----------------------------------------------------------------------------------------------------------------------
## renderMemberDeclarations($fields)
## Renders test-class member declarations for the given List<Variable>.
## Param: $fields - the list of variables for which to render declarations.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderMemberDeclarations $fields)
    #foreach($field in $fields)
        #if($field.shouldBeMocked) @Mock #end
        private $field.type.canonicalText $field.testClassMemberName;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethods($methods)
## Renders tests for the given List<Method>. This filters out getters/setters and other methods for which tests should
## not be rendered.
## Param: $methods - the list of methods for which to render tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethods $methods)
    #if($sourceClass.enum)
        #set($macro.methodsToUse = $methods)
    #else
        #set($macro.methodsToUse = $methods.filterOut('simpleGetterOrSetter').filterOut('abstract'))
    #end
    #foreach($method in $macro.methodsToUse)
        #if($method.shouldUseSimpleTest)
            #renderSimpleTestMethod($method)
        #else
            #renderTestMethodForPrimaryFlow($method)
            #renderTestMethodsForAltFlows($method)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForPrimaryFlow($method)
## Renders primary flow test case for the given Method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForPrimaryFlow $method)
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.testInfo = $TestInfo.primaryFlow($method, $macro.mockedDIs))
    #renderTestMethod($macro.testInfo)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodsForAltFlows($method)
## Renders test for alternate flows for the given method.
## Param: $method - the method for which to render alt-flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodsForAltFlows $method)
    ## Render tests for exceptions declared by the source method.
    ## Determine if at at least one dependency interaction that we've mocked throws an exception.
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.shouldRenderTestsForIoParams = $method.static || !($sourceClass.enumValues.size() > 1))
    #set($macro.runtimeOrNonJdkExRegex = '(java\.lang\.RuntimeException|^(?!java\.).+)')
    #set($macro.atLeastOneParamHasIo = $method.parameters.containsAnyWithNonNull('type.brokenIoInitExpression'))
    #set($macro.shouldRenderTestsForDeclaredExceptions = $macro.mockedDIs.empty && !$macro.atLeastOneParamHasIo && !$method.alwaysThrows)
    #set($macro.allSourceMethodExceptions = $method.declaredExceptions.union($method.javadocExceptions, 'type.canonicalName'))
    #if(!$generateStubsAndVerifyStatements)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
        #break
    #end
    ## Render alternate flow tests based on parameters.
    #if($macro.shouldRenderTestsForIoParams)
        #foreach($param in $method.parameters)
            #if($param.type.emptyIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithEmptyIo($method, $macro.mockedDIs, $param))
            #end
            #if($param.type.brokenIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithBrokenIo($method, $macro.mockedDIs, $param))
            #end
        #end
    #end
    ## Render alternate flow tests based on the dependency interactions.
    #foreach($di in $macro.mockedDIs)
        ## Determine info about the DI method return type.
        #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
        #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
        #set($macro.isAnyFuture = $di.method.returnType.isAny('java.util.concurrent.Future'))
        #set($macro.firstTypeParamCanBeEmpty = $StringUtils.isNotEmpty($di.method.returnType.parameters.first.emptyInitExpression))
        #set($macro.firstTypeParamCanBeAbsent = $di.method.returnType.parameters.first.absentInitExpression && !$StringUtils.equals($di.method.returnType.parameters.first.absentInitExpression, 'null'))
        #set($macro.shouldRenderAbsentTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored &&
            ($di.method.returnTypeCanBeAbsent || ($macro.isListenableFuture && $macro.firstTypeParamCanBeAbsent)))
        #set($macro.shouldRenderEmptyTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored &&
            ($di.method.returnType.emptyInitExpression || ($macro.isListenableFuture && $macro.firstTypeParamCanBeEmpty)))
        #set($macro.shouldRenderEmptyIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
            ($di.method.returnType.emptyIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty || ($macro.isListenableFuture && $di.method.returnType.parameters.first.emptyIoInitExpression)))
        #set($macro.shouldRenderBrokenIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
            ($di.method.returnType.brokenIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty || ($macro.isListenableFuture && $di.method.returnType.parameters.first.brokenIoInitExpression)))
        #set($macro.shouldRenderFailureTest = !($di.field.type.isAny('java.util.concurrent.Executor') && $macro.isAnyFuture) && ($di.method.returnType.failureInitExpression || $macro.isStandardFuture || $macro.isListenableFuture))
        #if(!$di.method.declaredExceptions.empty)
            #set($macro.diExceptionsToUse = $di.method.declaredExceptions)
        #else
            #set($macro.diExceptionsToUse = $di.method.javadocExceptions.filterItemsWithRegex('type.canonicalName', $macro.runtimeOrNonJdkExRegex))
        #end
        #set($macro.diExceptionsToUse = $macro.diExceptionsToUse.union($di.method.undeclaredExceptions, 'type.canonicalName'))
        ## Render the alt flow tests.
        #if($macro.shouldRenderAbsentTest)
            ## Render the test case where this dependency interaction returns either null or an absent value.
            #renderTestMethod($TestInfo.fromDiToReturnAbsent($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyTest)
            ## Render the test case where this dependency interaction returns an empty value.
            #renderTestMethod($TestInfo.fromDiToReturnEmpty($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnEmptyIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderBrokenIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnBrokenIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderFailureTest)
            #renderTestMethod($TestInfo.fromDiToReturnFailure($method, $macro.mockedDIs, $di))
        #end
        #foreach($exception in $macro.diExceptionsToUse)
            #renderTestMethod($TestInfo.fromDiThatThrows($method, $macro.mockedDIs, $di, $exception))
        #end
    #end
    #if($macro.shouldRenderTestsForDeclaredExceptions)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
## Renders alt-flow tests where the provided $method is expected to throw the provided $exceptions.
## Param: $method - the method for which to render alt-flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #foreach($declaredException in $exceptions)
        #renderTestMethod($TestInfo.fromExpectedException($method, $macro.mockedDIs, $declaredException))
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethod($testInfo)
## Renders the test for the given Method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethod $testInfo)
#set($_ = $CodeStyleUtils.beginMethodScope())
#if($sourceClass.enum)
    #renderTestMethodForEnum($testInfo)
#elseif($sourceClass.packageVisibleStaticCreatorMethods.contains($testInfo.method) && !$sourceClass.singleton && !$testInfo.expectedException && !$testInfo.paramWithEmptyIo && !$testInfo.paramWithBrokenIo)
    #renderStaticCreatorMethodPrimaryFlowTest($testInfo)
#else
    ## Determine if we should create an assertEquals(...) call.
    #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.shouldCreateAssertEqualsCall =
        $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array || $testInfo.expectedValueNull)
        && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $testInfo.expectedValueEmpty || $testInfo.expectedValueAbsent || $macro.returnTypeIsArrayWithComparableType)
        && !$testInfo.expectedException)
    #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple && !$testInfo.expectedValueEmpty && !$testInfo.expectedValueAbsent)
    ## Determine the test case suffix to use for this test method and store the result in: $testCaseSuffix.
    #determineTestCaseSuffix($testInfo)

    @Test
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() throws Exception {
    // Setup
    ## Declare parameters to use to invoke the method.
    #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
        #if($param == $testInfo.paramWithEmptyIo)
            #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
        #elseif($param == $testInfo.paramWithBrokenIo)
            #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
        #else
            #declareAndInitLocalVar($param, true)
        #end
    #end
    #if($macro.shouldStoreExpectedValue)
        #declareAndInitLocalVar($testInfo.method.returnType, true)
    #end
    #renderStubs($testInfo)

    // Run the test
    #set($macro.qualifier = "#if($testInfo.method.static)${sourceClass.canonicalNameOrName}#else${sourceClass.testClassMemberName}#end")
    #if($testInfo.expectedException)
        assertThrows(${testInfo.expectedException.type.canonicalNameOrName}.class, () -> ${macro.qualifier}.#methodCall($testInfo.method, false));
    #else
        #if($testInfo.method.returnType) final $testInfo.method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);

        // Verify the results
        #if($macro.shouldCreateAssertEqualsCall)
            #if($testInfo.expectedValueNull)
                assertNull(result);
            #elseif($testInfo.expectedValueTrue)
                assertTrue(result);
            #else
                #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #elseif($testInfo.expectedValueEmpty)$testInfo.method.returnType.emptyInitExpression #elseif($testInfo.expectedValueAbsent)$testInfo.method.returnType.absentInitExpression #else $testInfo.method.returnType.initExpression #end")
                #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
            #end
        #end
    #end
    #renderVerifyStatements($testInfo)
    }
#end
#set($_ = $CodeStyleUtils.endMethodScope())
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStaticCreatorMethodPrimaryFlowTest($testInfo)
## Renders the primary flow test case for the given static method that returns an instance of the SourceClass.
## This test case calls methods on the returned source class to ensure it was created properly by the static method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStaticCreatorMethodPrimaryFlowTest $testInfo)
    #set($macro.shouldRenderSetup = $testInfo.method.parameters.containsAnyWith('shouldStoreInReference', true))
    @Test
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}() throws Exception {
    #if($macro.shouldRenderSetup)
        // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end

    #end
    // Run the test
    final $testInfo.method.returnType.canonicalText $testInfo.method.returnType.testClassLocalFieldName = ${sourceClass.canonicalNameOrName}.#methodCall($testInfo.method, false);
    #set($macro.instanceMethodsToCall = $sourceClass.allNonObjectLowestOverrideMethods.filterOut('static').filter('accessLevel', 'public', 'packagePrivate').filterOut('returnType', $Null).filterOut('simpleSetter').filterOutItemsWithRegex('name', '^(set|with|update)[A-Z0-9_]+.*'))
    #foreach($instanceMethod in $macro.instanceMethodsToCall)
        #foreach($param in $instanceMethod.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end
        ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
        ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
        ## evaluate the block and assign the result in a set statement.
        #define($__workaroundCallExpression) ${testInfo.method.returnType.testClassLocalFieldName}.#methodCall($instanceMethod, false) #end
        #set($macro.callExpression = "$__workaroundCallExpression")
        #assertEqualsCall($instanceMethod.returnType.initExpression, $macro.callExpression, $instanceMethod.returnType);
    #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## assertEqualsCall($expected, $actual, $type)
## Renders the assertEquals method call appropriate for the given parameters.
## Param: $expected - the value to use for the expected argument of the assertEquals method call.
## Param: $actual - the value to use for the actual argument of the assertEquals method call.
## Param: $type - the Type of the arguments; this is used to determine which assertEquals method to call.
##----------------------------------------------------------------------------------------------------------------------
#macro(assertEqualsCall $expected, $actual, $type)
    #if($type.array) assertArrayEquals($expected, $actual) #break ## break is needed to avoid adding a newline.
    #elseif($StringUtils.equalsAny($type.canonicalName, 'double', 'java.lang.Double')) assertEquals($expected, $actual, 0.0001) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'float', 'java.lang.Float')) assertEquals($expected, $actual, 0.0001) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'boolean', 'java.lang.Boolean')) assertFalse($actual) #break
    #else assertEquals($expected, $actual) #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStubs($testInfo)
## Renders the stubs (when, doAnswer, doThrow, etc) for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStubs $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #renderAbsentStub($di)
        #elseif($testInfo.shouldReturnEmpty($di))
            #renderEmptyStub($di)
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #renderEmptyIoStub($di)
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #renderBrokenIoStub($di)
        #elseif($testInfo.shouldThrowException($di))
            #renderExceptionStub($di, $testInfo.getExceptionToThrow($di))
        #elseif($testInfo.shouldReturnFailure($di))
            #renderFailureStub($di)
        #else
            #renderPrimaryFlowStub($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($dis)
## Renders the primary flow stubs (when, doAnswer, etc) for the given dependency interactions.
## Param: $dis - the dependency interactions to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStubs $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowStub($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($di)
## Renders the primary flow stub (when, doAnswer, etc) for the given dependency interaction.
## Param: $di - the dependency interaction to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if($di.method.parameters.containsAnyWith('type.canonicalName', 'java.lang.Runnable'))
        #renderAnswerForRunnable($di)
    #elseif($di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable'))
        #renderAnswerForCallable($di)
    #elseif($di.method.returnType)
        #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
        ## Declare a local variable for the return type if needed.
        #if($di.method.returnType.shouldStoreInReference)

            // Configure ${di.field.type.name}.${di.method.name}(...).
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
        #set($macro.returnTypeExpression = "#if($di.method.returnType.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.initExpression #end")
        #if($macro.hasInnerWildcardType)
            $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
        #else
            $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
        #end
        #if($di.method.returnType.shouldStoreInReference) $Newline #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForRunnable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Runnable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForRunnable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfRunnable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.lang.Runnable'))
    $doAnswer(invocation -> {
        ((Runnable) invocation.getArguments()[$macro.indexOfRunnable]).run();
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(null);
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
            final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(null);
            return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
            final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
            $doReturn(null).$when(mockFuture).get();
            $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
        #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
        #else
            return null;
        #end
    }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForCallable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Callable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForCallable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfCallable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.util.concurrent.Callable'))
    $doAnswer(invocation -> {
        final Callable<?> callable = (Callable<?>) invocation.getArguments()[$macro.indexOfCallable];
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(callable.call());
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
            final com.google.common.util.concurrent.SettableFuture settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(callable.call());
            return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
            final java.util.concurrent.ScheduledFuture<?> mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
            $doReturn(callable.call()).$when(mockFuture).get();
            $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
        #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
        #else
            return null;
        #end
    }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExceptionStub($di, $exceptionToThrow)
## Configures the provided dependency interaction ($di) to throw the provided $exceptionToThrow.
## Param: $di - the dependency interaction to be configured to throw.
## Param: $exceptionToThrow - the exception the $di should throw.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExceptionStub $di, $exceptionToThrow)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if($di.method.returnType)
        $when($macro.qualifier.#methodCall($di.method, false)).$thenThrow(${exceptionToThrow.type.canonicalNameOrName}.class);
    #else
        $doThrow(${exceptionToThrow.type.canonicalNameOrName}.class).$when($macro.qualifier).#methodCall($di.method, false);
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAbsentStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAbsentStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = !$di.method.inferredNullable && ($macro.isListenableFuture || $di.method.returnType.shouldBeSpied))
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.absentInitExpression)
        #elseif($di.method.returnType.shouldBeSpied)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.absentInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.absentInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.emptyIoInitExpression)
        #elseif($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, true, false, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyIoInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBrokenIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBrokenIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.brokenIoInitExpression)
        #elseif($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, false, true, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.brokenIoInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.brokenIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.emptyInitExpressionIsLong = $di.method.returnType.emptyInitExpression && $ClassUtils.removePackageQualifiers($di.method.returnType.emptyInitExpression).length() > 40)
    #set($macro.shouldStoreInReference = ($di.method.returnType.shouldStoreInReference && ($di.method.returnType.shouldBeMocked || $macro.emptyInitExpressionIsLong)) || $di.method.returnType.shouldBeSpied || $macro.isListenableFuture)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFuture($di.method.returnType, $di.method.returnType.parameters.first.emptyInitExpression)
        #elseif($di.method.returnType.shouldBeSpied || $macro.emptyInitExpressionIsLong)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyInitExpression, false)
        #else
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderFailureStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderFailureStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isListenableFuture = $ListenableFutureNames.contains($di.method.returnType.canonicalName))
    #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
    #set($macro.shouldStoreInReference = $di.method.returnType.shouldStoreInReference || $di.method.returnType.shouldBeSpied || $macro.isListenableFuture || ($macro.isStandardFuture && !$di.method.returnType.failureInitExpression))
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($macro.isListenableFuture)
            #declareAndInitListenableFutureFailureCase($di.method.returnType)
        #elseif($macro.isStandardFuture && !$di.method.returnType.failureInitExpression)
            #declareAndInitCompletableFutureFailureCase($di.method.returnType)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.failureInitExpression, false)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.failureInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVar($param, $addNewlineAfterBean)
## Declares and initializes a local variable for $param. If $param is a DTOBean, Squaretest will initialize its
## properties. Squaretest also initializes any DTOBeans required for the $param's initialization expression.
## Param: $param               - the Type or Variable to declare and initialize.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVar $param, $addNewlineAfterBean = false)
    #if($ListenableFutureNames.contains($param.type.canonicalName))
        #declareAndInitListenableFuture($param, false)
    #else
        #declareAndInitLocalVarImpl($param, false, $addNewlineAfterBean)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarImpl($param, $addNewlineAfterBean)
## The implementation for declareAndInitLocalVar(..).
## Param: $param - the Type or Variable to declare and initialize.
## Param: $initExpressionToUse (optional) - The init expression to use inline for the $param (or false).
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarImpl $param, $initExpressionToUse = false, $addNewlineAfterBean = false)
    #set($macro.isOrHasBean = $param.type.dtoBean || !$param.type.initExpressionBeans.empty)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #if($initExpressionToUse)
        final $param.type.canonicalText $param.testClassLocalFieldName = $initExpressionToUse;
    #elseif($param.type.dtoBean)
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
        #renderBeanSetupCodeForVar($param, false, false)
        #if($addNewlineAfterBean) $Newline #end
    #elseif(!$param.type.initExpressionBeans.empty)
        ## The parameter's initExpression has one or more beans; e.g. the bean in Optional.of(bean).
        ## Declare and init the beans first.
        #foreach($beanType in $param.type.initExpressionBeans)
            ## Declare the local field for the bean and initialize it.
            #declareAndInitLocalVar($beanType, false)
        #end
        #set($param.type.initExpression = $param.type.createInitExpressionWithLocalFieldBeans($param.type.initExpressionBeans))
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #else
        final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarBeanWithAltIo($param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean)
## Declares and initializes a bean using an alternate IO init expression for its IO property.
## Param: $param             - the Type or Variable to declare and initialize.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarBeanWithAltIo $param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean = false)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    final $param.type.canonicalText $param.testClassLocalFieldName = $param.type.initExpression;
    #renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #if($addNewlineAfterBean) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitListenableFuture($param, $innerTypeInitExpression)
## Declares and initializes a ListenableFuture or SettableFuture.
## Param: $param                               - the Type or Variable to declare and initialize.
## Param: $innerTypeInitExpression (optional)  - The init expression to use for the Future's type parameter (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitListenableFuture $param, $innerTypeInitExpression = false)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #set($macro.shouldSetInnerType = $innerTypeInitExpression || !$param.type.parameters.first.canonicalText.equals('?'))
    #set($macro.shouldStoreInnerTypeInVar = !$innerTypeInitExpression && $macro.shouldSetInnerType && !$param.type.parameters.first.simple)
    #set($macro.settableFutureInfo = $ListenableFutureToSettableFutureMap.get("$param.type.canonicalName"))
    #if($macro.shouldStoreInnerTypeInVar)
        #declareAndInitLocalVar($param.type.parameters.first, false)
    #end
    final $macro.settableFutureInfo[0]<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = $macro.settableFutureInfo[1];
    #if($macro.shouldSetInnerType)
        #if($innerTypeInitExpression)
            ${param.testClassLocalFieldName}.set($innerTypeInitExpression);
        #elseif($macro.shouldStoreInnerTypeInVar)
            ${param.testClassLocalFieldName}.set($param.type.parameters.first.testClassLocalFieldName);
        #else
            ${param.testClassLocalFieldName}.set($param.type.parameters.first.initExpression);
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitListenableFutureFailureCase($param)
## Declares and initializes a ListenableFuture or SettableFuture with an Exception result.
## Param: $param - the Type or Variable to declare and initialize.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitListenableFutureFailureCase $param)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #set($macro.settableFutureInfo = $ListenableFutureToSettableFutureMap.get("$param.type.canonicalName"))
    final $macro.settableFutureInfo[0]<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = $macro.settableFutureInfo[1];
    ${param.testClassLocalFieldName}.setException(new java.lang.Exception("message"));
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitCompletableFutureFailureCase($param)
## Declares and initializes a Future or CompletableFuture with an Exception result. This is needed to support Java 8.
## In Java 9+ CompletableFuture.failedFuture(exception) is used to construct the future with an exception result.
## Param: $param - the Type or Variable to declare and initialize.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitCompletableFutureFailureCase $param)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    final java.util.concurrent.CompletableFuture<$param.type.parameters.first.canonicalText> $param.testClassLocalFieldName = new java.util.concurrent.CompletableFuture<>();
    ${param.testClassLocalFieldName}.completeExceptionally(new java.lang.Exception("message"));
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
## Renders the code necessary to configure the provided bean.
## Param: $param - the Type or Variable for which to render the bean setup code.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeForVar $param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #set($macro.canonicalNamesInCallStack = {})
    #set($macro.canonicalNamesInCallStack[$param.type.canonicalName] = true)
    #set($macro.numberOfSettersCalled = $MutableInt.create(0))
    #renderBeanSetupCodeRecursively($param, $BeanContext.create($param, $minNumberOfSettersToCall, $maxNumberOfSettersToCall), $shouldUseEmptyIo, $shouldUseBrokenIo, $macro.canonicalNamesInCallStack, $macro.numberOfSettersCalled)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeRecursively(..)
## This should only be called from the #renderBeanSetupCodeForVar() macro.
## Renders the code necessary to configure the provided bean and its properties that are beans or lists of beans.
## Param: $typeOrVariable         - the Type or Variable for which to render the bean setup code.
## Param: $beanContext            - the context describing how to initialize the top level bean and its sub beans.
## Param: $shouldUseEmptyIo  - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $canonicalNamesInCallStack - the canonical names of beans in the recursive init call stack. This is used to
##        avoid infinite recursive loops.
## Param: $numberOfSettersCalled     - MutableInt containing the total number of setters called in this recurisve call.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeRecursively $typeOrVariable, $beanContext, $shouldUseEmptyIo, $shouldUseBrokenIo, $canonicalNamesInCallStack, $numberOfSettersCalled)
    #set($macro.beanClass = $ClassUtils.resolveBean($beanContext, $typeOrVariable))
    #if(!$macro.beanClass)#break #end
    #set($macro.beanClass.testClassLocalFieldName = $typeOrVariable.testClassLocalFieldName)
    #set($macro.preferredSetters = $macro.beanClass.preferredInitMethods)
    #foreach($setter in $macro.preferredSetters)
        #if($numberOfSettersCalled.intValue() >= $beanContext.maxSettersToCall)#break #end
        #set($_ = $numberOfSettersCalled.increment())
        #if($setter.jaxbListGetter)
            #set($macro.param = $setter.returnType)
        #else
            #set($macro.param = $setter.parameters.first)
        #end
        #if($macro.param.type.generic && $typeOrVariable.type.parameters.size() == 1 && !$typeOrVariable.type.parameters.first.generic)
            #set($macro.param = $typeOrVariable.type.parameters.first)
        #end
        #if($macro.param.type.dtoBean)
            #if(!$canonicalNamesInCallStack[$macro.param.type.canonicalName])
                #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($macro.param))
                final $macro.param.type.canonicalText $macro.param.testClassLocalFieldName = $macro.param.initExpression;
                ## Store the beans cannonical name in map to avoid entering a recursive loop.
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = true)
                #renderBeanSetupCodeRecursively($macro.param, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = false)
                #set($macro.param.shouldStoreInReference = true)
            #else
                #set($macro.param.shouldStoreInReference = false)
            #end
        #elseif(!$macro.param.type.initExpressionBeans.empty)
            ## The setter's param's initExpression contains at least one bean.
            #foreach($beanType in $macro.param.type.initExpressionBeans)
                #if(!$canonicalNamesInCallStack[$beanType.canonicalName])
                    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($beanType))
                    final $beanType.canonicalText $beanType.testClassLocalFieldName = $beanType.initExpression;
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = true)
                    #renderBeanSetupCodeRecursively($beanType, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = false)
                    #set($beanType.shouldStoreInReference = true)
                #else
                    #set($beanType.shouldStoreInReference = false)
                #end
            #end
            #set($macro.param.type.initExpression = $macro.param.type.createInitExpressionWithLocalFieldBeans($macro.param.type.initExpressionBeans.filter('shouldStoreInReference')))
            #set($macro.param.shouldStoreInReference = false)
        #else
            #set($macro.param.shouldStoreInReference = false)
        #end
        #if($setter.jaxbListGetter)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}().addAll($macro.param.type.initExpression);
        #elseif($shouldUseEmptyIo && $macro.param.type.emptyIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.emptyIoInitExpression);
        #elseif($shouldUseBrokenIo && $macro.param.type.brokenIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.brokenIoInitExpression);
        #else
            #if($macro.param.shouldStoreInReference)
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.testClassLocalFieldName);
            #else
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.initExpression);
            #end
        #end
    #end
    #renderExtraBeanSetupCode($macro.beanClass)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraBeanSetupCode($beanSourceClass)
## Renders any extra statements needed to initialize the instance of the $beanSourceClass.
## Param: $beanSourceClass - the SourceClass for the bean to render extra initialization code for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraBeanSetupCode $beanSourceClass)
    #if($StringUtils.equalsAny($beanSourceClass.type.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        final com.amazonaws.services.s3.model.S3Object spyS3Object = spy(new com.amazonaws.services.s3.model.S3Object());
        spyS3Object.setBucketName("bucketName");
        spyS3Object.setKey("key");
        spyS3Object.setObjectContent(new java.io.ByteArrayInputStream("objectContent".getBytes()));
        ${beanSourceClass.testClassLocalFieldName}.setS3Object(spyS3Object);
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderVerifyStatements($testInfo)
## Renders verify statements for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderVerifyStatements $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #if($di.method.inferredNullable && $di.method.returnType.shouldBeSpied)
                ## Do nothing. The DI normally returns a closeable. It's returning null in this case, so no verify(..) is needed.
            #elseif($di.returnValueIgnored || $di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmpty($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #if($di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldThrowException($di))
            ## Do nothing.
        #elseif($testInfo.shouldReturnFailure($di))
            #if($di.returnValueIgnored || $di.method.returnType.closeable)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #else
            #renderPrimaryFlowVerifyStatement($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatements($dis)
## Renders primary flow verify statements for the given dependency interactions ($dis).
## Param: $dis - the dependency interactions to render the primary flow verify statements for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatements $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowVerifyStatement($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatement($di)
## Renders primary flow verify statement for the given dependency interactions ($di).
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatement $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.qualifier = "#if($shouldSetPackageLocalFields)${sourceClass.testClassMemberName}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #if(!$di.method.returnType)
        #if($shouldUseMockitoBdd)
            then($macro.qualifier).should().#methodCall($di.method, false);
        #else
            verify($macro.qualifier).#methodCall($di.method, false);
        #end
    #elseif($di.method.returnType.closeable && $di.method.returnType.shouldStoreInReference)
        #if($shouldUseMockitoBdd)
            then($di.method.returnType.testClassLocalFieldName).should().close();
        #else
            verify($di.method.returnType.testClassLocalFieldName).close();
        #end
    #elseif($di.returnValueIgnored)
        #if($shouldUseMockitoBdd)
            then($macro.qualifier).should().#methodCall($di.method, false);
        #else
            verify($macro.qualifier).#methodCall($di.method, false);
        #end
    #end
    #renderExtraVerifyStatements($di)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraVerifyStatements($di)
## Renders any extra verify statements needed for the provided dependency interaction.
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraVerifyStatements $di)
    #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        #if($shouldUseMockitoBdd)
            then(spyS3Object).should().close();
        #else
            verify(spyS3Object).close();
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## methodCall($method, $assumeArgsAreStoredInMembers)
## Renders an expression to call the given method. This does not include any qualifiers required to reference
## the method.
## Param: $method - the method or constructor for which to render the call-expression.
## Param: $assumeArgsAreStoredInMembers (optional) - assumes the arguments are stored in member fields instead of
##        local fields.
## Note: This macro uses multiline comments: #* and *# to avoid adding newlines.
##----------------------------------------------------------------------------------------------------------------------
#macro(methodCall $method, $assumeArgsAreStoredInMembers = false)#*
    *#${method.name}#if($method.constructor && $sourceClass.hasGenerics)<>#end#*
    *#(#foreach($param in $method.parameters)#*
        *##if(!$param.shouldStoreInReference)#*
            *#$param.initExpression#*
        *##elseif($assumeArgsAreStoredInMembers)#*
            *#$param.testClassMemberName#*
        *##else#*
            *#$param.testClassLocalFieldName#*
        *##end#*
        *##if($foreach.hasNext),#end#*
    *##end)#*
*##end

##----------------------------------------------------------------------------------------------------------------------
## determineTestCaseSuffix($testInfo)
## Determines the suffix to use for the given test case and stores the result in $testCaseSuffix.
## Param: $testInfo - information about which case this test should cover.
## Out:   $testCaseSuffix - the suffix to use for this test case.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineTestCaseSuffix $testInfo)
    #set($macro.disToUse = $testInfo.method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #if($testInfo.subjectDi)
        #if($macro.disToUse.filterOutItemsWithSameSourceVar($testInfo.subjectDi).containsAnyWith('field.type.name', $testInfo.subjectDi.field.type.name))
            #set($macro.fieldName = "$StringUtils.capitalize($testInfo.subjectDi.field.declaredNameWithoutPrefix)")
        #else
            #set($macro.fieldName = "${testInfo.subjectDi.field.type.name}")
        #end
        #if($macro.disToUse.filterItemsWithSameSourceVar($testInfo.subjectDi).size() > 1)
            #set($macro.descriptionPart1 = "_${macro.fieldName}$StringUtils.capitalize($testInfo.subjectDi.method.name)")
        #else
            #set($macro.descriptionPart1 = "_${macro.fieldName}")
        #end
    #end
    #if($testInfo.paramWithEmptyIo)
        #set($testCaseSuffix = '_Empty' + $StringUtils.capitalize($testInfo.paramWithEmptyIo.declaredName))
    #elseif($testInfo.paramWithBrokenIo)
        #set($testCaseSuffix = '_Broken' + $StringUtils.capitalize($testInfo.paramWithBrokenIo.declaredName))
    #elseif($testInfo.subjectDiExceptionToThrow)
        #set($testCaseSuffix = "${macro.descriptionPart1}Throws${testInfo.subjectDiExceptionToThrow.type.name}")
    #elseif($testInfo.subjectDiReturnsFailure)
        #if($StringUtils.containsIgnoreCase($testInfo.subjectDi.method.returnType.failureInitExpression, 'Error'))
            #set($macro.returnSuffix = 'ReturnsError')
        #else
            #set($macro.returnSuffix = 'ReturnsFailure')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.subjectDiReturnsEmpty)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoItems')
    #elseif($testInfo.subjectDiReturnsEmptyIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoContent')
    #elseif($testInfo.subjectDiReturnsBrokenIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsBrokenIo')
    #elseif($testInfo.subjectDiReturnsAbsent)
        #if($testInfo.subjectDi.method.inferredNullable)
            #set($macro.returnSuffix = 'ReturnsNull')
        #elseif($testInfo.subjectDi.method.returnType.optional)
            #set($macro.returnSuffix = 'ReturnsAbsent')
        #else
            #set($macro.returnSuffix = 'ReturnsNoItem')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.expectedException)
        #set($testCaseSuffix = "_Throws${testInfo.expectedException.type.name}")
    #else
        #set($testCaseSuffix = '')
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForEnum($testInfo)
## Renders the enum test method for the given Method. This is similar to #renderTestMethod($method) but calls the
## method on each value in the enum and adds an assertEquals call for each result.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForEnum $testInfo)
    #set($macro.multipleValuesTest = $sourceClass.enumValues.size() > 1 && !$testInfo.method.static)
    #set($macro.paramsToStoreInFields = $testInfo.method.parameters.filter('shouldStoreInReference', true))
    #set($macro.shouldRenderSetup = $macro.paramsToStoreInFields.size() > 0 || ($testInfo.method.returnType && !$testInfo.expectedException))
    #determineTestCaseSuffix($testInfo)
    #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.shouldCreateAssertEqualsCall =
        !$macro.multipleValuesTest && $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array)
        && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType)
        && !$testInfo.expectedException)
    #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple)
    #set($macro.shouldRenderSimpleMultivalueTest = $macro.multipleValuesTest && ($testInfo.method.returnType || $testInfo.expectedException))
    #if($macro.shouldRenderSimpleMultivalueTest)
        #renderSimpleMultivalueTestMethodForEnum($testInfo)
        #break($macro)
    #end
    @Test
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() throws Exception {
        #if($macro.shouldRenderSetup)
            // Setup
            ## Declare parameters to use to invoke the method.
            #foreach($param in $macro.paramsToStoreInFields)
                #if($param == $testInfo.paramWithEmptyIo)
                    #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
                #elseif($param == $testInfo.paramWithBrokenIo)
                    #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
                #else
                    #declareAndInitLocalVar($param, true)
                #end
            #end
            #if($macro.shouldStoreExpectedValue)
                #declareAndInitLocalVar($testInfo.method.returnType, true)
            #end

        #end
        // Run the test
        #set($macro.qualifier = "#if($testInfo.method.static)${sourceClass.canonicalNameOrName}#else${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#end")
        #if($testInfo.expectedException)
            assertThrows(${testInfo.expectedException.type.canonicalNameOrName}.class, () -> ${macro.qualifier}.#methodCall($testInfo.method, false));
        #elseif($macro.multipleValuesTest)
            #foreach($enumValue in $sourceClass.enumValues)
                ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false);
            #end
        #else
            #if($testInfo.method.returnType) final $testInfo.method.returnType.canonicalText result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);
        #end
        #if(!$testInfo.expectedException)

            // Verify the results
            #if($macro.shouldCreateAssertEqualsCall)
                #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #else $testInfo.method.returnType.initExpression #end")
                #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
            #end
        #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleMultivalueTestMethodForEnum($testInfo)
## Renders a simple test method for the given $testInfo. The method contains assertions for all
## values in the enum.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSimpleMultivalueTestMethodForEnum $testInfo)
    #set($testCaseSuffix = "#if($testInfo.expectedException)_Throws${testInfo.expectedException.type.name}#end")
    #foreach($param in $testInfo.method.parameters)
        #set($param.shouldStoreInReference = false)
    #end
    @Test
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() throws Exception {
        #foreach($enumValue in $sourceClass.enumValues)
            #if($testInfo.expectedException)
                assertThrows(${testInfo.expectedException.type.canonicalNameOrName}.class, () -> ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false));
            #else
                ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
                ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
                ## evaluate the block and assign the result in a set statement.
                #define($__workaroundCallExpression) ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false) #end
                #set($macro.callExpression = "$__workaroundCallExpression")
                #assertEqualsCall($testInfo.method.returnType.initExpression, $macro.callExpression, $testInfo.method.returnType);
            #end
        #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleTestMethod($method)
## Renders a simple test method for the given $method.
## Param: $method - the method for which to render the simple test method.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSimpleTestMethod $method)
    #set($macro.allSourceMethodExceptions = $method.declaredExceptions.union($method.javadocExceptions, 'type.canonicalName'))
    #set($macro.simplyExits = $method.simpleExitInfo.returnExpression || $method.simpleExitInfo.thrownException)
    #set($macro.shouldRenderAltFlowTests = $method.parameters.size() > 0 && !$macro.simplyExits)
    @Test
    void test${StringUtils.capitalize(${method.name})}${method.overloadSuffix}() throws Exception {
    #set($macro.qualifier = "#if($method.static)${sourceClass.canonicalNameOrName}#elseif($sourceClass.enum)${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#else${sourceClass.testClassMemberName}#end")
    ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
    ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
    ## evaluate the block and assign the result in a set statement.
    #define($__workaroundCallExpression) ${macro.qualifier}.#methodCall($method, false) #end
    #set($macro.callExpression = "$__workaroundCallExpression")
    #if($method.simpleExitInfo.returnExpression)
        #if($StringUtils.equals($method.simpleExitInfo.returnExpression, 'null'))
            assertNull($macro.callExpression);
        #elseif($StringUtils.equalsAny($method.simpleExitInfo.returnExpression, 'true', 'java.lang.Boolean.TRUE'))
            assertTrue($macro.callExpression);
        #else
            #assertEqualsCall($method.simpleExitInfo.returnExpression, $macro.callExpression, $method.returnType);
        #end
    #elseif($method.simpleExitInfo.thrownException)
        assertThrows(${method.simpleExitInfo.thrownException.type.canonicalNameOrName}.class, () -> ${macro.qualifier}.#methodCall($method, false));
    #else
        #assertEqualsCall($method.returnType.initExpression, $macro.callExpression, $method.returnType);
    #end
    #if($macro.shouldRenderAltFlowTests)
        ## Render an assertNull(...) call if one is needed.
        #if($method.returnTypeCanBeAbsent)
            #if($method.inferredNullable)
                assertNull($macro.callExpression);
            #elseif($method.returnType.overridesEquals)
                #assertEqualsCall($method.returnType.absentInitExpression, $macro.callExpression, $method.returnType);
            #end
        #end
        #if($method.returnType.emptyInitExpression)
            #assertEqualsCall($method.returnType.emptyInitExpression, $macro.callExpression, $method.returnType);
        #end
        ## Render an assertThrows(...) call for each exception declared by the method.
        #foreach($declaredException in $macro.allSourceMethodExceptions)
            assertThrows(${declaredException.type.canonicalNameOrName}.class, () -> ${macro.qualifier}.#methodCall($method, false));
        #end
    #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## Generates an inline mock expression to create a mock for type: $classToMock in a way that is consistent with the
## $useStaticImportForInitMocks quick setting.
## Param: $classToMock - the name or canonical name of the class to mock.
##----------------------------------------------------------------------------------------------------------------------
#macro(mock $classToMock)
    #if($useStaticImportForInitMocks)
        mock($classToMock)
    #else
        Mockito.mock($classToMock)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderImportsForMatchers()
## Renders import statements for the mockito matchers; i.e. any(), eq(), etc.
## Matchers will be imported from org.mockito.ArgumentMatchers if it is available on the test classpath or if none of
## the mockito classes are on the test classpath. Otherwise, if org.mockito.Matchers is present on the classpath and
## org.mockito.ArgumentMatchers is not, Squaretest will import the matchers from org.mockito.Matchers.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderImportsForMatchers)
    #set($macro.matcherCanonicalName = 'org.mockito.ArgumentMatchers')
    #if((!$ClassUtils.isInTestClasspath($macro.matcherCanonicalName))
        && $ClassUtils.isInTestClasspath('org.mockito.Matchers'))
        #set($macro.matcherCanonicalName = 'org.mockito.Matchers')
    #end
    import static ${macro.matcherCanonicalName}.any;
    import static ${macro.matcherCanonicalName}.anyInt;
    import static ${macro.matcherCanonicalName}.anyString;
    import static ${macro.matcherCanonicalName}.eq;
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeTemplateDataModel()
## Updates mutable fields in $sourceClass and $importLinesRequired based on the Quick Settings at the top of the file
## and the architype of the source class. This also sets additional variables used in the rendering logic.
## Using a macro to prepare the data model separates the test-class rendering-logic from the configuration and
## class architype-detection logic; this keeps the rendering logic simple and easy to modify.
##
## Global Variables Set by #initializeTemplateDataModel:
##
##   $dependencies                  a List<Variable> containing all fields the test class should provide for the
##                                  instance of the source class.
##   $memberFields                  a subset of $dependencies containing only fields that should be stored in members
##                                  in the test class.
##   $mockMemberFields              a subset of $memberFields containing only fields that should be mocked.
##
##   $nonMockMemberFields           a subset of $memberFields containing only fields that should not be mocked.
##
##   $sourceClassMemberNeeded       a boolean indicating whether or not an instance of the source class should be
##                                  created and stored in a member of the test class.
##   $shouldUseInjectMocks          a boolean indicating whether or not @InjectMocks should be used to provide
##                                  dependencies to the instance of the source class.
##   $shouldSetPackageLocalFields   a boolean indicating whether or not the test class should provide dependencies
##                                  to the source class by setting package-local fields.
##   $mocksNeeded                   true if source class has at least one dependency that should be mocked.
##
##   $shouldCreateTestsForInstanceMethods
##                                  a boolean indicating whether or not test should be created for the instance methods
##                                  in the source class.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeTemplateDataModel)
    ## Define ListenableFuture to SettableFutures map.
    ## If your company uses a fork of ListenableFuture, add an entry here to improve test generation.
    ## The format is: 'ListenableFutureCanonicalName' : ['SettableFutureCanonicalName', 'SettableFutureInitExpression'].
    #set($ListenableFutureToSettableFutureMap = {
        'com.google.common.util.concurrent.ListenableFuture':
            ['com.google.common.util.concurrent.SettableFuture', 'com.google.common.util.concurrent.SettableFuture.create()'],
        'com.google.common.util.concurrent.SettableFuture':
            ['com.google.common.util.concurrent.SettableFuture', 'com.google.common.util.concurrent.SettableFuture.create()'],
        'com.google.api.core.ApiFuture':
            ['com.google.api.core.SettableApiFuture', 'com.google.api.core.SettableApiFuture.create()'],
        'com.google.api.core.SettableApiFuture':
            ['com.google.api.core.SettableApiFuture', 'com.google.api.core.SettableApiFuture.create()'],
        'org.springframework.util.concurrent.ListenableFuture':
            ['org.springframework.util.concurrent.SettableListenableFuture', 'new org.springframework.util.concurrent.SettableListenableFuture<>()'],
        'org.springframework.util.concurrent.SettableListenableFuture':
            ['org.springframework.util.concurrent.SettableListenableFuture', 'new org.springframework.util.concurrent.SettableListenableFuture<>()']
    })
    #set($ListenableFutureNames = $ListenableFutureToSettableFutureMap.keySet())
    ## Determine information about JUnit and Mockito versions on the test classpath.
    #set($hasOpenMocksMethod = false)
    #set($initMocksMethodName = 'initMocks')
    #set($macro.mockitoAnnotationsSourceClass = $ClassUtils.resolveClass('org.mockito.MockitoAnnotations'))
    #if($macro.mockitoAnnotationsSourceClass && $macro.mockitoAnnotationsSourceClass.methods.containsAnyWith('name', 'openMocks'))
        #set($hasOpenMocksMethod = true)
        #set($initMocksMethodName = 'openMocks')
    #end
    #if($shouldUseMockitoBdd)
        #set($doAnswer = 'willAnswer')
        #set($doReturn = 'willReturn')
        #set($thenReturn = 'willReturn')
        #set($when = 'given')
        #set($doThrow = 'willThrow')
        #set($thenThrow = 'willThrow')
    #else
        #set($doAnswer = 'doAnswer')
        #set($doReturn = 'doReturn')
        #set($thenReturn = 'thenReturn')
        #set($when = 'when')
        #set($doThrow = 'doThrow')
        #set($thenThrow = 'thenThrow')
    #end
    ## Determine the archetype of the source class and set the global variables accordingly.
    #set($shouldCreateTestsForInstanceMethods = true)
    #set($mutablePackageLocalInstanceFields = $sourceClass.packageLocalInstanceFields.filter('final', false))
    ## Add the simple names or cannonical names of any custom dependency annotations to the method call below.
    #set($dependencyAnnotatedFields = $sourceClass.fieldsAnnotatedWith('Inject', 'Autowired', 'Resource', 'PersistenceContext'))
    #if($sourceClass.enum)
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
    #elseif($sourceClass.instanceMethods.empty && !$sourceClass.staticMethods.empty)
        ## The source class only has static methods; it's likely a utils class.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
    #elseif($sourceClass.abstract && !$sourceClass.packageVisibleStaticCreatorMethods.empty)
        ## The source class is abstract and has static creator methods. Only create tests for those. The static creator
        ## test methods invoke the instance methods.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
        #set($shouldCreateTestsForInstanceMethods = false)
    #elseif($sourceClass.sealedAbstract)
        ## The source class is a sealed abstract class. If we have a preferred constructor, use its arguments for the
        ## dependencies. That way the user can simply replace the constructor call with its appropriate subclass constructor call.
        #if($sourceClass.preferredConstructor)
            #set($dependencies = $sourceClass.preferredConstructor.parameters)
        #else
            #set($dependencies = $FluentList.emptyList())
        #end
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.abstract && !$sourceClass.preferredConstructor)
        ## The source class is an abstract class, but does not have a visible constructor or static creator methods.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$sourceClass.preferredConstructor.parameters.empty)
        ## The source class has a parameterized constructor; use it to provide the dependencies.
        #set($dependencies = $sourceClass.preferredConstructor.parameters)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.filter('private', true).empty)
        ## The source class has a no-args constructor and private fields annotated with @Inject or @Autowired.
        #set($shouldUseInjectMocks = true)
        #set($dependencies = $dependencyAnnotatedFields)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$dependencyAnnotatedFields.empty)
        ## The source class has a no-args constructor and visible, dependency-annotated fields;
        ## the test class should set them.
        #set($dependencies = $dependencyAnnotatedFields)
        #set($shouldSetPackageLocalFields = true)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor && !$mutablePackageLocalInstanceFields.empty)
        ## The source class has a no-args constructor and mutable package-local instance fields; assume they are
        ## dependencies and have the test class set them.
        #set($dependencies = $mutablePackageLocalInstanceFields)
        #set($shouldSetPackageLocalFields = true)
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.preferredConstructor)
        ## The source class has a visible constructor but no package-local fields or dependency-annotated fields.
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif($sourceClass.singleton)
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #elseif(!$sourceClass.packageVisibleStaticCreatorMethods.empty)
        ## The source class has no visible constructor, but does have static creator methods; e.g. parse(...), from(...).
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = false)
        #set($shouldCreateTestsForInstanceMethods = false)
    #else
        #set($dependencies = $FluentList.emptyList())
        #set($sourceClassMemberNeeded = true)
    #end
    ## Update the mutable fields on the dependencies based on the Quick Settings.
    #setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
    ## Filter out fields that should not be stored as members in the test class.
    #set($memberFields = $dependencies.filter('shouldStoreInReference', true))
    #set($mockMemberFields = $memberFields.filter('shouldBeMocked', true))
    #set($nonMockMemberFields = $memberFields.filter('shouldBeMocked', false))
    #set($mocksNeeded = !$mockMemberFields.empty || $shouldUseInjectMocks)
    #initializeMethodParamsWithQuickSettings()
    #initializeMethodReturnTypes()
    #initializeDependencyInteractionMethodParams()
    #askUserToConfirmSettingsIfNeeded()
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodReturnTypes()
## Sets the returnType.testClassLocalFieldName of each method to 'expectedResult'.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodReturnTypes)
    #foreach($method in $sourceClass.allMethods)
        #if($method.returnType)
            #if($sourceClass.packageVisibleStaticCreatorMethods.contains($method))
                #set($method.returnType.testClassLocalFieldName = 'result')
            #else
                #set($method.returnType.testClassLocalFieldName = 'expectedResult')
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodParamsWithQuickSettings()
## Sets mutable fields on the method parameters based on Quick Settings.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodParamsWithQuickSettings)
    #foreach($method in $sourceClass.allMethods)
    #foreach($param in $method.parameters)
        #if($param.type.generic && $sourceClass.packageVisibleStaticCreatorMethods.contains($method))
            ## Use inline args for generic types in static creator methods; e.g. Pair.of(left, right), ImmutableList.of(T...).
            #set($param.shouldStoreInReference = false)
        #elseif($useMocksForListenerAndCallbackParameters
            && $param.type.mockable
            && ($StringUtils.endsWithIgnoreCase($param.declaredName, "listener")
                || $StringUtils.endsWithIgnoreCase($param.declaredName, "callback")))
            ## If useMocksForListenerAndCallbackParameters is set it takes precedence over any initExpressionOverrides.
            #if($param.used)
                #useInlineMockForParam($param)
                #set($param.shouldStoreInReference = true)
            #else
                #set($param.shouldStoreInReference = false)
            #end
        #elseif(!$param.used && $param.type.initExpression == 'null')
            #set($param.shouldStoreInReference = false)
        #elseif($initExpressionOverrides.containsKey($param.type.canonicalName))
            ## Check the initExpressionOverrides.
            #set($macro.initExpressionOverride = false)
            #set($macro.initExpressionOverride = $initExpressionOverrides.get($param.type.canonicalName))
            #if($macro.initExpressionOverride)
                #set($param.initExpression = $macro.initExpressionOverride.initExpression)
                #set($param.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
                #set($param.shouldBeMocked = false)
                #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
            #end
        #elseif($param.type.recognized && $param.type.shouldBeMocked)
            #useInlineMockForParam($param)
            #set($param.shouldStoreInReference = true)
        #else
            #set($param.shouldBeMocked = false)
        #end
        #setTestClassNamesForParam($param)
    #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## setDependencyNamesAndInitExpressions($dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
## Sets mutable fields on the $params based on the Quick Settings.
## Param: $dependencies the List<Variable> containing the dependencies.
## Param: $shouldUseInjectMocks
##          a boolean indicating whether or not @InjectMocks should be used to provide dependencies to the instance
##          of the source class.
## Param: $shouldSetPackageLocalFields
##          a boolean indicating whether or not the test class should provide dependencies to the source class by
##          setting package-local fields.
##----------------------------------------------------------------------------------------------------------------------
#macro(setDependencyNamesAndInitExpressions $dependencies, $shouldUseInjectMocks, $shouldSetPackageLocalFields)
    #foreach($dependency in $dependencies)
        ## Use the initExpressionOverride if one is present and we do not need to use @InjectMocks.
        #set($macro.initExpressionOverride = false)
        #set($macro.initExpressionOverride = $initExpressionOverrides.get($dependency.type.canonicalName))
        #if($macro.initExpressionOverride && !$shouldUseInjectMocks)
            #set($dependency.initExpression = $macro.initExpressionOverride.initExpression)
            #set($dependency.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
            #set($dependency.shouldBeMocked = false)
            #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
        #elseif($shouldUseInjectMocks && $dependency.type.mockable)
            #set($dependency.shouldBeMocked = true)
            #set($dependency.shouldStoreInReference = true)
        #elseif(!$dependency.shouldBeMocked)
            #set($dependency.shouldStoreInReference = false)
        #end
        ## If the dependencies are provided by setting package-local fields, set them inline instead of storing
        ## references to them in the test class.
        #if($shouldSetPackageLocalFields)
            #if($dependency.shouldBeMocked)
                #useInlineMockForParam($dependency)
            #end
            #set($dependency.shouldStoreInReference = false)
        #end
        #setTestClassNamesForParam($dependency)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodParams()
## Updates the data model to use inline initialization expressions for the method arguments in stub (when) and verify
## expressions.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodParams)
    #foreach($method in $sourceClass.allMethods)
    #foreach($di in $method.dependencyInteractions)
        #initializeDependencyInteractionMethodReturnType($di)
        ## Set the parameter init expressions to either values or matcher expressions.
        #set($macro.hasCallableOrRunnableParam = $di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable','java.lang.Runnable'))
        #set($macro.hasParamRequiringMatcher = $macro.hasCallableOrRunnableParam || $di.methodCallExpression.arguments.filterOut('actualType.primitive').filterOut('declaredType.classT').containsAnyWith('actualType.overridesEquals', false))
    #foreach($param in $di.method.parameters)
        #set($macro.actualType = $di.methodCallExpression.arguments.get($foreach.index).actualType)
        #set($param.shouldStoreInReference = false)
        ## Handle Callables and Runnables.
        #if($param.type.canonicalName == 'java.util.concurrent.Callable')
            #set($param.initExpression = '(Callable<?>) any(Callable.class)')
        #elseif($param.type.canonicalName == 'java.lang.Runnable')
            #set($param.initExpression = 'any(Runnable.class)')
        ## Handle Class<T> arguments; e.g. Foo.class.
        #elseif($param.type.classT)
            #set($macro.classExpression = "${macro.actualType.canonicalNameOrName}.class")
            #if($macro.hasParamRequiringMatcher)
                #set($param.initExpression = "eq($macro.classExpression)")
            #else
                #set($param.initExpression = "$macro.classExpression")
            #end
        ## Handle generic type arguments; e.g. T, not List<T>.
        #elseif($param.type.generic)
            #if(!$macro.hasParamRequiringMatcher)
                ## Use values for all arguments.
                #set($param.initExpression = $macro.actualType.initExpression)
            #elseif($macro.actualType.primitive || $macro.actualType.overridesEquals)
                ## We need to use matchers. Use eq(...) if possible.
                #set($param.initExpression = "eq($macro.actualType.initExpression)")
            #else
                ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                #set($param.initExpression = "any(${macro.actualType.canonicalNameOrName}.class)")
            #end
        ## Handle the case where the formal parameter is an interface or abstract class that does not override
        ## Object.equals, but the actual type does.
        #elseif(!$param.type.overridesEquals && $macro.actualType.overridesEquals)
            #if(!$macro.hasParamRequiringMatcher)
                ## Use values for all arguments.
                #set($param.initExpression = $macro.actualType.initExpression)
            #else
                ## We need to use matchers. Use eq(...).
                #set($param.initExpression = "eq($macro.actualType.initExpression)")
            #end
        ## Handle all remaining cases where we need to use matchers.
        #elseif($macro.hasParamRequiringMatcher)
            #if($param.type.primitive || $param.type.overridesEquals || $macro.actualType.overridesEquals)
                ## We need to use matchers. Use eq(...) if possible.
                #set($param.initExpression = "eq($param.initExpression)")
            #else
                ## We need to use matchers. A custom matcher is needed to validate the argument. Use any(...) for now.
                #set($param.initExpression = "any(${param.type.canonicalNameOrName}.class)")
            #end
        #end
    #end
    #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodReturnType($di)
## Initializes the initExpression, testClassLocalFieldName and other fields in the $di.method.returnType.
## Param: $di the dependency interaction whose return type will be initialized.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodReturnType $di)
    #if($di.method.returnType.dtoBean || !$di.method.returnType.initExpressionBeans.empty)
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
    #if($ListenableFutureNames.contains($di.method.returnType.canonicalName))
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
    #if($di.method.returnType.closeable)
        #set($di.method.returnType.shouldStoreInReference = true)
        #if($di.method.returnType.initExpression.equals('null'))
            #set($di.method.returnType.shouldBeMocked = true)
        #else
            #useInlineSpyForParam($di.method.returnType)
            #set($di.method.returnType.testClassLocalFieldName = "spy$StringUtils.capitalize($di.method.returnType.name)")
        #end
    #end
    #if($di.method.returnType.shouldBeMocked)
        #set($di.method.returnType.shouldStoreInReference = true)
        #useInlineMockForParam($di.method.returnType)
        #set($di.method.returnType.testClassLocalFieldName = "mock$StringUtils.capitalize($di.method.returnType.name)")
    #end
    #if($ClassUtils.removePackageQualifiers($di.method.returnType.initExpression).length() > 40)
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## setTestClassNamesForParam($param)
## Sets the Variable.testClassMemberName and Variable.testClassLocalFieldName properties on the given $param
## based on the Quick Settings.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(setTestClassNamesForParam $param)
    #if($param.shouldBeMocked)
        #if(${StringUtils.isNotEmpty($mockDependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${mockDependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #elseif (${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
        #if(${StringUtils.isNotEmpty($mockParameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${mockParameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #elseif (${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
    #else
        #if(${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
        #if(${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${param.declaredNameWithoutPrefix})}")
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineMockForParam($param)
## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineMockForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.mock;"))
    #else
        #set($param.initExpression = "Mockito.mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineSpyForParam($param)
## Updates the given parameter to use an inline mock expression; e.g. mock(Foo.class) wherever the parameter is needed.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineSpyForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "spy($param.initExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.spy;"))
    #else
        #set($param.initExpression = "Mockito.spy($param.initExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "Mockito.spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "Mockito.spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "Mockito.spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "Mockito.spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = false)
    #set($param.shouldBeSpied = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## askUserToConfirmSettingsIfNeeded()
## Shows a dialog asking the user to confirm which dependencies should be mocked if the template was invoked with
## $shouldAskToConfirmSettings = true. The variable: $shouldAskToConfirmSettings is true when the user invokes the
## "Generate Test - Confirm Mocks" action from the Squaretest menu.
##----------------------------------------------------------------------------------------------------------------------
#macro(askUserToConfirmSettingsIfNeeded)
    #if($shouldAskToConfirmSettings)
        ## Show the dialog to ask the user to confirm the provided settings.
        #set($userProvidedSettings =
            $UiUtils.askUserToConfirmSettings({
                'dependencies' : $dependencies,
                'memberFields' : $memberFields,
                'mockMemberFields' : $mockMemberFields,
                'nonMockMemberFields' : $nonMockMemberFields,
                'sourceClassMemberNeeded' : $sourceClassMemberNeeded,
                'shouldUseInjectMocks' : $shouldUseInjectMocks,
                'shouldSetPackageLocalFields' : $shouldSetPackageLocalFields,
                'mocksNeeded' : $mocksNeeded,
                'shouldCreateTestsForInstanceMethods' : $shouldCreateTestsForInstanceMethods
        }))
        #set($dependencies = $userProvidedSettings.get('dependencies'))
        #set($memberFields = $userProvidedSettings.get('memberFields'))
        #set($mockMemberFields = $userProvidedSettings.get('mockMemberFields'))
        #set($nonMockMemberFields = $userProvidedSettings.get('nonMockMemberFields'))
        #set($sourceClassMemberNeeded = $userProvidedSettings.get('sourceClassMemberNeeded'))
        #set($shouldUseInjectMocks = $userProvidedSettings.get('shouldUseInjectMocks'))
        #set($shouldSetPackageLocalFields = $userProvidedSettings.get('shouldSetPackageLocalFields'))
        #set($mocksNeeded = $userProvidedSettings.get('mocksNeeded'))
        #set($shouldCreateTestsForInstanceMethods = $userProvidedSettings.get('shouldCreateTestsForInstanceMethods'))
    #end
#end

## Declare global variables set by initializeTemplateDataModel() to enable partial code completion in the Velocity
## editor bundled with the IntelliJ IDEA Ultimate Edition.
## Constants.
#* @vtlvariable name="ListenableFutureNames" type="java.util.Set<java.lang.String>" *#
#* @vtlvariable name="ListenableFutureToSettableFutureMap" type="java.util.Map<java.lang.String, java.util.List<java.lang.String>>" *#

## General data types.
#* @vtlvariable name="dependencies" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="memberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="mockMemberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="nonMockMemberFields" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="sourceClassMemberNeeded" type="boolean" *#
#* @vtlvariable name="shouldUseInjectMocks" type="boolean" *#
#* @vtlvariable name="shouldSetPackageLocalFields" type="boolean" *#
#* @vtlvariable name="mocksNeeded" type="boolean" *#
#* @vtlvariable name="shouldCreateTestsForInstanceMethods" type="boolean" *#
#* @vtlvariable name="initMocksMethodName" type="java.lang.String" *#
#* @vtlvariable name="hasOpenMocksMethod" type="boolean" *#

## Variables defined based on whether the $shouldUseMockitoBdd setting is enabled.
#* @vtlvariable name="doAnswer" type="java.lang.String" *#
#* @vtlvariable name="doReturn" type="java.lang.String" *#
#* @vtlvariable name="thenReturn" type="java.lang.String" *#
#* @vtlvariable name="when" type="java.lang.String" *#
#* @vtlvariable name="doThrow" type="java.lang.String" *#
#* @vtlvariable name="thenThrow" type="java.lang.String" *#

## Parameter names used in various macros.
#* @vtlvariable name="testInfo" type="com.squaretest.template.api.Api.TestInfo" *#
#* @vtlvariable name="exceptionToThrow" type="com.squaretest.template.api.Api.Exception" *#
#* @vtlvariable name="dependency" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="methods" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="method" type="com.squaretest.template.api.Api.Method" *#
#* @vtlvariable name="param" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="typeOrVariable" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="type" type="com.squaretest.template.api.Api.Type" *#
#* @vtlvariable name="field" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="di" type="com.squaretest.template.api.Api.DependencyInteraction" *#
#* @vtlvariable name="testCaseSuffix" type="java.lang.String" *#
#* @vtlvariable name="beanSourceClass" type="com.squaretest.template.api.Api.SourceClass" *#
#* @vtlvariable name="shouldUseEmptyIo" type="boolean" *#
#* @vtlvariable name="shouldUseBrokenIo" type="boolean" *#
#* @vtlvariable name="numberOfSettersCalled" type="org.apache.commons.lang3.mutable.MutableInt" *#
#* @vtlvariable name="canonicalNamesInCallStack" type="java.util.Map<java.lang.String, java.lang.Boolean>" *#
