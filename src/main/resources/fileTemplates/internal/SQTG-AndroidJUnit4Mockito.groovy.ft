## Quick Settings - configure common code style and other settings here. -----------------------------------------------
## Set these to use special prefixes for test class members containing dependencies of certain types.
## Note that the template code below will ignore any prefix set to "" and use your IDE code style settings instead.
#set($dependencyMemberNamePrefix = "")
#set($mockDependencyMemberNamePrefix = "mock")
## Set this to use a special prefix for local fields containing arguments for test methods.
#set($parameterLocalFieldNamePrefix = "")
#set($mockParameterLocalFieldNamePrefix = "mock")
## Customize the name of the member and local field (if needed) used to store the instance of the source class.
#set($sourceClass.testClassMemberName = "${sourceClass.testClassMemberName}UnderTest")
#set($sourceClass.testClassLocalFieldName = "${sourceClass.testClassLocalFieldName}UnderTest")
#set($shouldUseMockitoBdd = false)
## Configure how Bean DTOs are initialized.
#set($minNumberOfSettersToCall = 5)
#set($maxNumberOfSettersToCall = 70)
## Set the name of the member used to store the ActivityTestRule if one is needed.
#set($activityTestRuleMemberName = "$CodeStyleUtils.suggestMemberName('ActivityTestRule')")
#set($useStaticImportForInitMocks = true)
## Set this to use mocks for mockable method parameters that end in "listener" or "callback" ignoring case.
#set($useMocksForListenerAndCallbackParameters = true)
#set($generateStubsAndVerifyStatements = true)
## Use this to specify custom initialization values for dependencies and method parameters of certain types;
## See https://squaretest.com#template_api_quick_settings for details.
#set($initExpressionOverrides = {'android.content.Context' : 'InstrumentationRegistry.getContext()'})
##----------------------------------------------------------------------------------------------------------------------

## Initialize the data model. This sets global variables based on the architype of the source class and Quick Settings.
## See the comments above the macro or https://squaretest.com#template_api_initializeTemplateDataModel for details.
#initializeTemplateDataModel()

## Render the package declaration.
#if($StringUtils.isNotEmpty($sourceClass.packageName))
package $sourceClass.packageName;
#end

## Render the imports.
#foreach($importLine in $importLinesRequired)
    $importLine
#end
#if($useStaticImportForInitMocks)
import static org.mockito.MockitoAnnotations.$initMocksMethodName;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
#end
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Future;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
#if($hasAssertThrows)
import static org.junit.Assert.assertThrows;
#end
#renderImportsForMatchers()
#if($shouldUseMockitoBdd)
import static org.mockito.BDDMockito.willAnswer;
import static org.mockito.BDDMockito.willReturn;
import static org.mockito.BDDMockito.willThrow;
import static org.mockito.BDDMockito.then;
import static org.mockito.BDDMockito.given;
#else
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
#end
import android.content.Intent;
#renderImportsForAndroidComponents()
import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.runner.RunWith;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.InjectMocks;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import groovy.transform.CompileStatic;

## Render the test class.
@CompileStatic
@RunWith(AndroidJUnit4.class)
#if($androidActivity) @LargeTest #else @SmallTest #end
class ${sourceClass.name}Test {

## Declare member fields for the mocked dependencies.
#renderMemberDeclarations($mockMembers)

## Declare a member field for the instance of the source class.
#if($shouldRenderSourceClassMember)
    #if($shouldUseInjectMocks) @InjectMocks #end
    private ${sourceClass.type.canonicalText} ${sourceClass.testClassMemberName};
#end
## Declare a rule to control the Activity if the source class is an Activity.
#if($shouldUseAndroidRule)
    @Rule
    public ActivityTestRule<$sourceClass.canonicalNameOrName> $activityTestRuleMemberName = new ActivityTestRule<>(${sourceClass.canonicalNameOrName}.class, false, false);
#end

#if($shouldRenderMockitoCloseable)
    private AutoCloseable mockitoCloseable;
#end

#if($shouldRenderSetupMethod)
@Before
void setUp() {
    #set($_ = $CodeStyleUtils.beginMethodScope())
    #if(!$mockMembers.empty)
        #set($initMocksQualifier = "#if(!$useStaticImportForInitMocks)MockitoAnnotations.#else#end")
        #if($hasOpenMocksMethod)
            mockitoCloseable = ${initMocksQualifier}${initMocksMethodName}(this);
        #else
            ${initMocksQualifier}${initMocksMethodName}(this);
        #end
    #end
    #if($shouldRenderSourceClassMember)
        #initializeSourceClass()
    #end
    #set($_ = $CodeStyleUtils.endMethodScope())
}
#end
#if($shouldRenderTearDownMethod)
@After
void tearDown() {
    mockitoCloseable.close();
}
#end
## Render the test methods.
#if($androidActivity)
    #renderActivityTestMethod()
#end
#renderTestMethods($methodsToTest)
}

##----------------------------------------------------------------------------------------------------------------------
## renderMemberDeclarations($params)
## Renders test class member declarations for the given FluentList<Variable>.
## Param: $params - the list of variables for which to render declarations.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderMemberDeclarations $params)
    #foreach($param in $params)
        #if($param.shouldBeMocked) @Mock #end
        private $param.type.canonicalText $param.testClassMemberName;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethods($methods)
## Renders tests for the given List<Method>. This filters out getters/setters and other methods for which tests should
## not be rendered.
## Param: $methods - the list of methods for which to render tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethods $methods)
    #foreach($method in $methods)
        #if($method.doesNothing)
            #renderDoNothingTest($method)
        #elseif(($method.getter || $method.setter) && !$sourceClass.enum)
            #renderGetterOrSetterTest($method)
        #elseif($method.shouldUseSimpleTest)
            #if($hasAssertThrows)
                #renderSimpleTestMethodWithAssertThrows($method)
            #elseif($method.simpleExitInfo.thrownException)
                #renderSimpleTestMethod($method, $method.simpleExitInfo.thrownException)
            #elseif($method.simpleExitInfo.returnExpression)
                #renderSimpleTestMethod($method, $Null)
            #else
                #renderTestMethodForPrimaryFlow($method)
                #renderTestMethodsForAltFlows($method)
            #end
        #else
            #renderTestMethodForPrimaryFlow($method)
            #renderTestMethodsForAltFlows($method)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForPrimaryFlow($method)
## Renders primary flow test case for the given Method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForPrimaryFlow $method)
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.testInfo = $TestInfo.primaryFlow($method, $macro.mockedDIs))
    #renderTestMethod($macro.testInfo)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodsForAltFlows($method)
## Renders test for alternate flows for the given method.
## Param: $method - the method for which to render alternate flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodsForAltFlows $method)
    ## Determine the alternate flow tests to create.
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #set($macro.shouldRenderTestsForIoParams = $method.static || !($sourceClass.enumValues.size() > 1))
    #set($macro.runtimeOrNonJdkExRegex = '(java\.lang\.RuntimeException|java\.util\.NoSuchElementException|^(?!java\.).+)')
    #set($macro.atLeastOneParamHasIo = $method.parameters.containsAnyWithNonNull('type.brokenIoInitExpression'))
    #set($macro.shouldRenderTestsForDeclaredExceptions = $macro.mockedDIs.empty && !$macro.atLeastOneParamHasIo && !$method.alwaysThrows)
    #set($macro.allSourceMethodExceptions = $method.declaredExceptions.union($method.javadocExceptions, 'type.canonicalName'))
    #if(!$generateStubsAndVerifyStatements)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
        #break
    #end
    ## Render alternate flow tests based on parameters.
    #if($macro.shouldRenderTestsForIoParams)
        #foreach($param in $method.parameters)
            #if($param.type.emptyIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithEmptyIo($method, $macro.mockedDIs, $param))
            #end
            #if($param.type.brokenIoInitExpression)
                #renderTestMethod($TestInfo.fromParamWithBrokenIo($method, $macro.mockedDIs, $param))
            #end
        #end
    #end
    ## Render alternate flow tests based on the dependency interactions.
    #foreach($di in $macro.mockedDIs)
        ## Determine info about the DI method return type.
        #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
        #set($macro.isAnyFuture = $di.method.returnType.isAny('java.util.concurrent.Future'))
        #set($macro.shouldRenderAbsentTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored && $di.method.returnTypeCanBeAbsent)
        #set($macro.shouldRenderEmptyTest = !$di.field.type.isAny('java.util.concurrent.Executor') && !$di.returnValueIgnored && $di.method.returnType.emptyInitExpression)
        #set($macro.shouldRenderEmptyIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
            ($di.method.returnType.emptyIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty))
        #set($macro.shouldRenderBrokenIoTest = !$di.field.type.isAny('java.util.concurrent.Executor') &&
            ($di.method.returnType.brokenIoInitExpression || $di.method.returnType.dtoBeanWithInputIoProperty))
        #set($macro.shouldRenderFailureTest = !($di.field.type.isAny('java.util.concurrent.Executor') && $macro.isAnyFuture) &&
            ($di.method.returnType.failureInitExpression || $macro.isStandardFuture) && !$di.returnValueIgnored)
        #if(!$di.method.declaredExceptions.empty)
            #set($macro.diExceptionsToUse = $FluentList.of())
            #foreach($exception in $di.method.declaredExceptions)
                #if($exception.checked || $exception.type.canonicalNameOrName.matches($macro.runtimeOrNonJdkExRegex))
                    #set($_ = $macro.diExceptionsToUse.add($exception))
                #end
            #end
        #else
            #set($macro.diExceptionsToUse = $di.method.javadocExceptions.filterItemsWithRegex('type.canonicalName', $macro.runtimeOrNonJdkExRegex))
        #end
        #set($macro.diExceptionsToUse = $macro.diExceptionsToUse.union($di.method.undeclaredExceptions, 'type.canonicalName'))
        ## Render the alt flow tests.
        #if($macro.shouldRenderAbsentTest)
            ## Render the test case where this dependency interaction returns either null or an absent value.
            #renderTestMethod($TestInfo.fromDiToReturnAbsent($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyTest)
            ## Render the test case where this dependency interaction returns an empty value.
            #renderTestMethod($TestInfo.fromDiToReturnEmpty($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderEmptyIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnEmptyIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderBrokenIoTest)
            #renderTestMethod($TestInfo.fromDiToReturnBrokenIo($method, $macro.mockedDIs, $di))
        #end
        #if($macro.shouldRenderFailureTest)
            #renderTestMethod($TestInfo.fromDiToReturnFailure($method, $macro.mockedDIs, $di))
        #end
        #foreach($exception in $macro.diExceptionsToUse)
            #renderTestMethod($TestInfo.fromDiThatThrows($method, $macro.mockedDIs, $di, $exception))
        #end
    #end
    #if($macro.shouldRenderTestsForDeclaredExceptions)
        #renderAltFlowTestsForDeclaredExceptions($method, $macro.allSourceMethodExceptions)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
## Renders alternate flow tests where the provided $method is expected to throw the provided $exceptions.
## Param: $method - the method for which to render alternate flow tests.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAltFlowTestsForDeclaredExceptions $method, $exceptions)
    #set($macro.mockedDIs = $method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #foreach($declaredException in $exceptions)
        #renderTestMethod($TestInfo.fromExpectedException($method, $macro.mockedDIs, $declaredException))
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethod($testInfo)
## Renders the test for the given Method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethod $testInfo)
#set($_ = $CodeStyleUtils.beginMethodScope())
#if($testInfo.method.shouldUseSimpleTest)
    #renderSimpleTestMethod($testInfo.method, $testInfo.expectedException)
#elseif($sourceClass.enum)
    #renderTestMethodForEnum($testInfo)
#elseif($sourceClass.packageVisibleStaticCreatorMethods.contains($testInfo.method) && !$sourceClass.singleton && !$testInfo.expectedException && !$testInfo.paramWithEmptyIo && !$testInfo.paramWithBrokenIo)
    #renderStaticCreatorMethodPrimaryFlowTest($testInfo)
#else
    ## Determine if we should create an assertEquals(...) call.
    #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.shouldCreateAssertEqualsCall =
        $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array || $testInfo.expectedValueNull)
        && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $testInfo.expectedValueEmpty || $testInfo.expectedValueAbsent || $macro.returnTypeIsArrayWithComparableType)
        && !$testInfo.expectedException)
    #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple && !$testInfo.expectedValueEmpty && !$testInfo.expectedValueAbsent)
    #set($macro.shouldRenderExceptionHeader = $testInfo.expectedException && !$hasAssertThrows)
    ## Determine the test case suffix to use for this test method and store the result in: $testCaseSuffix.
    #determineTestCaseSuffix($testInfo)

    @Test #if($macro.shouldRenderExceptionHeader)(expected = ${testInfo.expectedException.type.canonicalNameOrName}.class) #end
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() {
    // Setup
    ## Construct the source class if needed.
    #if(!$method.static && $shouldCreateSourceClassInEachTestMethod)
        #initializeSourceClass()
    #end
    ## Declare parameters to use to invoke the method.
    #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
        #if($param == $testInfo.paramWithEmptyIo)
            #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
        #elseif($param == $testInfo.paramWithBrokenIo)
            #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
        #else
            #declareAndInitLocalVar($param, true)
        #end
    #end
    #if($macro.shouldStoreExpectedValue)
        #declareAndInitLocalVar($testInfo.method.returnType, true)
    #end
    #renderStubs($testInfo)

    // Run the test
    #set($macro.qualifier = "#if($testInfo.method.static)${method.containingClass.canonicalNameOrName}#elseif($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #if($testInfo.expectedException)
        #if($hasAssertThrows)
            assertThrows(${testInfo.expectedException.type.canonicalNameOrName}.class, {
                ${macro.qualifier}.#methodCall($testInfo.method, false);
            });
            #renderVerifyStatements($testInfo)
        #else
            ${macro.qualifier}.#methodCall($testInfo.method, false);
        #end
    #else
        #if($testInfo.method.returnType) def result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);

        // Verify the results
        #if($macro.shouldCreateAssertEqualsCall)
            #if($testInfo.expectedValueNull)
                assertNull(result);
            #elseif($testInfo.expectedValueTrue)
                assertTrue(result);
            #else
                #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #elseif($testInfo.expectedValueEmpty)$testInfo.method.returnType.emptyInitExpression #elseif($testInfo.expectedValueAbsent)$testInfo.method.returnType.absentInitExpression #else $testInfo.method.returnType.initExpression #end")
                #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
            #end
        #end
        #renderVerifyStatements($testInfo)
    #end
    }
#end
#set($_ = $CodeStyleUtils.endMethodScope())
#end

##----------------------------------------------------------------------------------------------------------------------
## renderActivityTestMethod()
## Renders a test method that launches the Activity being tested.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderActivityTestMethod)
    #if($hasActivityScenario)
        #renderActivityTestMethodWithScenario()
    #else
        #renderActivityTestMethodWithRule()
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderActivityTestMethodWithScenario()
## Renders a test method that launches the Activity being tested using ActivityScenario.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderActivityTestMethodWithScenario)
    @Test
    public void testLaunchActivity() {
        // Run the test
        try(ActivityScenario<$sourceClass.canonicalNameOrName> scenario = ActivityScenario.launch(${sourceClass.canonicalNameOrName}.class)) {
            scenario.onActivity({ActivityScenario.ActivityAction<$sourceClass.canonicalNameOrName> activity ->
                // Verify the results
            });
        }
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderActivityTestMethodWithScenario()
## Renders a test method that launches the Activity being tested using the ActivityTestRule.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderActivityTestMethodWithRule)
    ## Declare variables for local field names used in multiple places.
    #set($intentFieldName = "$CodeStyleUtils.suggestLocalFieldName('Intent')")
    @Test
    void testLaunchActivity() {
        // Setup
        def $intentFieldName = new Intent();

        // Run the test
        ${activityTestRuleMemberName}.launchActivity($intentFieldName);

        // Verify the results
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStaticCreatorMethodPrimaryFlowTest($testInfo)
## Renders the primary flow test case for the given static method that returns an instance of the SourceClass.
## This test case calls methods on the returned source class to ensure it was created properly by the static method.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStaticCreatorMethodPrimaryFlowTest $testInfo)
    #set($macro.shouldRenderSetup = $testInfo.method.parameters.containsAnyWith('shouldStoreInReference', true))
    @Test
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}() {
    #if($macro.shouldRenderSetup)
        // Setup
        ## Declare parameters to use to invoke the method.
        #foreach($param in $testInfo.method.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end

    #end
    // Run the test
    def $testInfo.method.returnType.testClassLocalFieldName = ${sourceClass.canonicalNameOrName}.#methodCall($testInfo.method, false);
    #set($macro.instanceMethodsToCall = $sourceClass.allNonObjectLowestOverrideMethods.filterOut('static').filter('accessLevel', 'public', 'packagePrivate').filterOut('returnType', $Null).filterOut('setter').filterOutItemsWithRegex('name', '^(set|with|update)[A-Z0-9_]+.*'))
    #foreach($instanceMethod in $macro.instanceMethodsToCall)
        #foreach($param in $instanceMethod.parameters.filter('shouldStoreInReference', true))
            #declareAndInitLocalVar($param, true)
        #end
        ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
        ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
        ## evaluate the block and assign the result in a set statement.
        #define($__workaroundCallExpression) ${testInfo.method.returnType.testClassLocalFieldName}.#methodCall($instanceMethod, false) #end
        #set($macro.callExpression = "$__workaroundCallExpression")
        #assertEqualsCall($instanceMethod.returnType.initExpression, $macro.callExpression, $instanceMethod.returnType);
    #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderTestMethodForEnum($testInfo)
## Renders the enum test method for the given Method. This is similar to #renderTestMethod($method) but calls the
## method on each value in the enum and adds an assertEquals call for each result.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderTestMethodForEnum $testInfo)
    #set($macro.multipleValuesTest = $sourceClass.enumValues.size() > 1 && !$testInfo.method.static)
    #set($macro.paramsToStoreInFields = $testInfo.method.parameters.filter('shouldStoreInReference', true))
    #set($macro.shouldRenderSetup = $macro.paramsToStoreInFields.size() > 0 || ($testInfo.method.returnType && !$testInfo.expectedException))
    #determineTestCaseSuffix($testInfo)
    #set($macro.returnTypeIsArrayWithComparableType = $testInfo.method.returnType.array && ($testInfo.method.returnType.deepArrayComponentType.primitive || $testInfo.method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.shouldCreateAssertEqualsCall =
        !$macro.multipleValuesTest && $testInfo.method.returnType && ($testInfo.method.returnType.primitive || $testInfo.method.returnType.overridesEquals || $testInfo.method.returnType.array)
        && ($testInfo.method.returnType.classT || $testInfo.method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType)
        && !$testInfo.expectedException)
    #set($macro.shouldStoreExpectedValue = $macro.shouldCreateAssertEqualsCall && !$testInfo.method.returnType.simple)
    #set($macro.shouldRenderExceptionHeader = $testInfo.expectedException && !$hasAssertThrows)
    #set($macro.shouldRenderSimpleMultivalueTest = $macro.multipleValuesTest && ($testInfo.method.returnType || $testInfo.expectedException))
    #if($macro.shouldRenderSimpleMultivalueTest)
        #renderSimpleMultivalueTestMethodForEnum($testInfo)
        #break($macro)
    #end
    @Test #if($macro.shouldRenderExceptionHeader)(expected = ${testInfo.expectedException.type.canonicalNameOrName}.class) #end
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() {
        #if($macro.shouldRenderSetup)
            // Setup
            ## Declare parameters to use to invoke the method.
            #foreach($param in $macro.paramsToStoreInFields)
                #if($param == $testInfo.paramWithEmptyIo)
                    #declareAndInitLocalVarImpl($param, $param.type.emptyIoInitExpression, true)
                #elseif($param == $testInfo.paramWithBrokenIo)
                    #declareAndInitLocalVarImpl($param, $param.type.brokenIoInitExpression, true)
                #else
                    #declareAndInitLocalVar($param, true)
                #end
            #end
            #if($macro.shouldStoreExpectedValue)
                #declareAndInitLocalVar($testInfo.method.returnType, true)
            #end

        #end
        // Run the test
        #set($macro.qualifier = "#if($testInfo.method.static)${method.containingClass.canonicalNameOrName}#else${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#end")
        #if($testInfo.expectedException && $hasAssertThrows)
            assertThrows(${testInfo.expectedException.type.canonicalNameOrName}.class, {
                ${macro.qualifier}.#methodCall($testInfo.method, false);
            });
        #elseif($macro.multipleValuesTest)
            #foreach($enumValue in $sourceClass.enumValues)
                ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false);
            #end
        #else
            #if($testInfo.method.returnType && !$testInfo.expectedException) def result = #end ${macro.qualifier}.#methodCall($testInfo.method, false);
        #end
        #if(!$testInfo.expectedException)

            // Verify the results
            #if($macro.shouldCreateAssertEqualsCall)
                #set($macro.expectedValueExpression = "#if($macro.shouldStoreExpectedValue)$testInfo.method.returnType.testClassLocalFieldName #else $testInfo.method.returnType.initExpression #end")
                #assertEqualsCall($macro.expectedValueExpression, 'result', $testInfo.method.returnType);
            #end
        #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleMultivalueTestMethodForEnum($testInfo)
## Renders a simple test method for the given $testInfo. The method contains assertions for all
## values in the enum.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSimpleMultivalueTestMethodForEnum $testInfo)
    #set($testCaseSuffix = "#if($testInfo.expectedException)_Throws${testInfo.expectedException.type.name}#end")
    #set($macro.shouldRenderExceptionHeader = $testInfo.expectedException && !$hasAssertThrows)
    #foreach($param in $testInfo.method.parameters)
        #set($param.shouldStoreInReference = false)
    #end
    @Test #if($macro.shouldRenderExceptionHeader)(expected = ${testInfo.expectedException.type.canonicalNameOrName}.class) #end
    void test${StringUtils.capitalize(${testInfo.method.name})}${testInfo.method.overloadSuffix}${testCaseSuffix}() {
        #if($testInfo.expectedException && !$hasAssertThrows)
            ${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}.#methodCall($testInfo.method, false);
        #else
            #foreach($enumValue in $sourceClass.enumValues)
                #if($testInfo.expectedException)
                    assertThrows(${testInfo.expectedException.type.canonicalNameOrName}.class, {
                        ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false);
                    });
                #else
                    ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
                    ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
                    ## evaluate the block and assign the result in a set statement.
                    #define($__workaroundCallExpression) ${sourceClass.canonicalNameOrName}.${enumValue}.#methodCall($testInfo.method, false) #end
                    #set($macro.callExpression = "$__workaroundCallExpression")
                    #assertEqualsCall($testInfo.method.returnType.initExpression, $macro.callExpression, $testInfo.method.returnType);
                #end
            #end
        #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleTestMethod($method, $expectedException)
## Renders a simple test method for the given $method.
## Param: $method - the method for which to render the simple test method.
## Param: $expectedException - the declared exception to use in this test method (or false)
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSimpleTestMethod $method, $expectedException)
    #set($macro.simplyExits = $method.simpleExitInfo.returnExpression || $method.simpleExitInfo.thrownException)
    #set($macro.shouldRenderAltFlowTests = $method.parameters.size() > 0 && !$macro.simplyExits)
    #set($macro.testCaseSuffix = "#if($expectedException && !$macro.simplyExits)_Throws${expectedException.type.name}#end")
    @Test #if($expectedException)(expected = ${expectedException.type.canonicalNameOrName}.class) #end
    void test${StringUtils.capitalize(${method.name})}${method.overloadSuffix}${macro.testCaseSuffix}() {
    #if(!$method.static && $shouldCreateSourceClassInEachTestMethod)
        #initializeSourceClass()
    #end
    #set($macro.qualifier = "#if($method.static)${method.containingClass.canonicalNameOrName}#elseif($sourceClass.enum)${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#elseif($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
    ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
    ## evaluate the block and assign the result in a set statement.
    #define($__workaroundCallExpression) ${macro.qualifier}.#methodCall($method, false) #end
    #set($macro.callExpression = "$__workaroundCallExpression")
    #if($expectedException)
        $macro.callExpression;
    #elseif($method.simpleExitInfo.returnExpression)
        #if($StringUtils.equals($method.simpleExitInfo.returnExpression, 'null'))
            assertNull($macro.callExpression);
        #elseif($StringUtils.equalsAny($method.simpleExitInfo.returnExpression, 'true', 'java.lang.Boolean.TRUE'))
            assertTrue($macro.callExpression);
        #else
            #assertEqualsCall($method.simpleExitInfo.returnExpression, $macro.callExpression, $method.returnType);
        #end
    #else
        #assertEqualsCall($method.returnType.initExpression, $macro.callExpression, $method.returnType);
        #if($macro.shouldRenderAltFlowTests)
            ## Render an assertNull(...) call if one is needed.
            #if($method.returnTypeCanBeAbsent)
                #if($method.inferredNullable)
                    assertNull($macro.callExpression);
                #elseif($method.returnType.overridesEquals)
                    #assertEqualsCall($method.returnType.absentInitExpression, $macro.callExpression, $method.returnType);
                #end
            #end
            #if($method.returnType.emptyInitExpression)
                #assertEqualsCall($method.returnType.emptyInitExpression, $macro.callExpression, $method.returnType);
            #end
        #end
    #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSimpleTestMethodWithAssertThrows($method)
## Renders a simple test method for the given $method.
## Param: $method - the method for which to render the simple test method.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSimpleTestMethodWithAssertThrows $method)
    #set($macro.allSourceMethodExceptions = $method.declaredExceptions.union($method.javadocExceptions, 'type.canonicalName'))
    #set($macro.simplyExits = $method.simpleExitInfo.returnExpression || $method.simpleExitInfo.thrownException)
    #set($macro.shouldRenderAltFlowTests = $method.parameters.size() > 0 && !$macro.simplyExits)
    @Test
    void test${StringUtils.capitalize(${method.name})}${method.overloadSuffix}() {
    #if(!$method.static && $shouldCreateSourceClassInEachTestMethod)
        #initializeSourceClass()
    #end
    #set($macro.qualifier = "#if($method.static)${method.containingClass.canonicalNameOrName}#elseif($sourceClass.enum)${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#elseif($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    ## There is a bug in the Velocity engine where macro calls in set statements don't work correctly when the
    ## VM_PERM_INLINE_LOCAL setting is enabled. To work around this, define a VTL block containing the macro call, then
    ## evaluate the block and assign the result in a set statement.
    #define($__workaroundCallExpression) ${macro.qualifier}.#methodCall($method, false) #end
    #set($macro.callExpression = "$__workaroundCallExpression")
    #if($method.simpleExitInfo.returnExpression)
        #if($StringUtils.equals($method.simpleExitInfo.returnExpression, 'null'))
            assertNull($macro.callExpression);
        #elseif($StringUtils.equalsAny($method.simpleExitInfo.returnExpression, 'true', 'java.lang.Boolean.TRUE'))
            assertTrue($macro.callExpression);
        #else
            #assertEqualsCall($method.simpleExitInfo.returnExpression, $macro.callExpression, $method.returnType);
        #end
    #elseif($method.simpleExitInfo.thrownException)
        assertThrows(${method.simpleExitInfo.thrownException.type.canonicalNameOrName}.class, {
            ${macro.qualifier}.#methodCall($method, false);
        });
    #else
        #assertEqualsCall($method.returnType.initExpression, $macro.callExpression, $method.returnType);
    #end
    #if($macro.shouldRenderAltFlowTests)
        ## Render an assertNull(...) call if one is needed.
        #if($method.returnTypeCanBeAbsent)
            #if($method.inferredNullable)
                assertNull($macro.callExpression);
            #elseif($method.returnType.overridesEquals)
                #assertEqualsCall($method.returnType.absentInitExpression, $macro.callExpression, $method.returnType);
            #end
        #end
        #if($method.returnType.emptyInitExpression)
            #assertEqualsCall($method.returnType.emptyInitExpression, $macro.callExpression, $method.returnType);
        #end
        ## Render an assertThrows(...) call for each exception declared by the method.
        #foreach($declaredException in $macro.allSourceMethodExceptions)
            assertThrows(${declaredException.type.canonicalNameOrName}.class, {
                ${macro.qualifier}.#methodCall($method, false);
            });
        #end
    #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderGetterOrSetterTest($method)
## Renders an appropriate test for the provided getter or setter method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderGetterOrSetterTest $method)
    #if($methodsAlreadyTested.containsKey($method))
        #break($macro)
    #end
    #set($macro.sourceVar = $method.targetField.possibleSourceVariables.intersection($dependencies).first)
    #if($method.getter)
        #if($method.targetField.setters.first && !$dependencies.contains($method.targetField.setters.first.parameters.first))
            #renderCombinedGetterSetterTest($method)
            #set($methodsAlreadyTested[$method.targetField.setters.first] = true)
        #else
            #renderGetterTest($method)
        #end
        #break($macro)
    #end
    #if($method.setter)
        #if($dependencies.contains($method.parameters.first))
            ## Do nothing. The setter is used to provide a dependency and is therefore tested in all of the tests.
            #break($macro)
        #end
        #if($method.targetField.getters.first)
            #renderCombinedGetterSetterTest($method)
            #set($methodsAlreadyTested[$method.targetField.getters.first] = true)
        #else
            #renderSetterTest($method)
        #end
        #break($macro)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderCombinedGetterSetterTest($method)
## Renders a combined getter and setter test for the provided method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderCombinedGetterSetterTest $method)
#set($_ = $CodeStyleUtils.beginMethodScope())
    #if($method.getter)
        #set($macro.getter = $method)
        #set($macro.setter = $method.targetField.setters.first)
    #else
        #set($macro.setter = $method)
        #set($macro.getter = $method.targetField.getters.first)
    #end
    ## Determine the test method name.
    #set($macro.baseName = $StringUtils.capitalize($macro.getter.targetField.declaredNameWithoutPrefix))
    #if($getterSetterTestNamesUsed.containsKey($macro.baseName))
        #set($getterSetterTestNamesUsed[$macro.baseName] = $getterSetterTestNamesUsed.get($macro.baseName) + 1)
        #set($macro.baseName = $macro.baseName + $getterSetterTestNamesUsed[$macro.baseName])
    #else
        #set($getterSetterTestNamesUsed[$macro.baseName] = 0)
    #end
    #set($macro.testName = 'test' +  $macro.baseName  + 'GetterAndSetter')
    ## Determine other variables.
    #set($macro.qualifier = "#if($method.static)${method.containingClass.canonicalNameOrName}#elseif($sourceClass.enum)${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#elseif($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.getterCallExpression = $macro.qualifier + '.' + $macro.getter.name + '()')
    #set($macro.returnTypeIsArrayWithComparableType = $method.returnType.array && ($method.returnType.deepArrayComponentType.primitive || $method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.canCompareValues =
        ($method.returnType.primitive || $method.returnType.overridesEquals || $method.returnType.array)
        && ($method.returnType.classT || $method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType))
    #if(!$macro.canCompareValues)
        ## If the type does not override equals and is not comparable, we need to store in a ref.
        #set($macro.setter.parameters.first.shouldStoreInReference = true)
    #end
    @Test
    void ${macro.testName}() {
        #if($shouldCreateSourceClassInEachTestMethod)
            #initializeSourceClass()
        #end
        #if($macro.setter.parameters.first.shouldStoreInReference)
            #declareAndInitLocalVarImpl($macro.setter.parameters.first, $macro.setter.parameters.first.initExpression, false)
        #end
        #if($macro.setter.parameters.first.shouldStoreInReference)
            #set($macro.expectedValueExpression = $macro.setter.parameters.first.testClassLocalFieldName)
        #else
            #set($macro.expectedValueExpression = $macro.setter.parameters.first.initExpression)
        #end
        ${macro.qualifier}.#methodCall($macro.setter, false);
        #assertEqualsCall($macro.expectedValueExpression, $macro.getterCallExpression, $macro.setter.parameters.first.type);
    }
#set($_ = $CodeStyleUtils.endMethodScope())
#end

##----------------------------------------------------------------------------------------------------------------------
## renderGetterTest($method)
## Renders a test for the provided getter method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderGetterTest $method)
    #set($macro.qualifier = "#if($testInfo.method.static)${method.containingClass.canonicalNameOrName}#elseif($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.getterCallExpression = $macro.qualifier + '.' + $method.name + '()')
    #set($macro.returnTypeIsArrayWithComparableType = $method.returnType.array && ($method.returnType.deepArrayComponentType.primitive || $method.returnType.deepArrayComponentType.overridesEquals))
    #set($macro.canCompareValues =
        ($method.returnType.primitive || $method.returnType.overridesEquals || $method.returnType.array)
        && ($method.returnType.classT || $method.returnType.allNestedTypeParamsOverrideEquals || $macro.returnTypeIsArrayWithComparableType))
    #set($macro.shouldStoreExpectedValue = false)
    ## Find the dependency that was used to provide a value to the getter's field.
    #set($macro.sourceVar = $method.targetField.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.expectedValueRef = $Null)
    #if($macro.sourceVar)
        #if($macro.sourceVar.shouldStoreInReference)
            #if($macro.sourceVar.shouldBeMocked)
                #set($macro.expectedValueRef = $macro.sourceVar.testClassMemberName)
            #elseif($shouldCreateSourceClassInEachTestMethod)
                #set($macro.expectedValueRef = $macro.sourceVar.testClassLocalFieldName)
            #end
        #end
    #end
    #if(!$macro.expectedValueRef)
        #if($macro.canCompareValues)
            ## If the value is comparable, declare and init.
            #if(!$method.returnType.initExpressionBeans.empty)
                #set($macro.shouldStoreExpectedValue = true)
            #else
                #set($macro.expectedValueRef = $method.returnType.initExpression)
            #end
        #elseif($method.targetField.visibleToTestClass)
            #set($macro.expectedValueRef = ${macro.qualifier} + '.' + ${method.targetField.declaredName})
        #end
    #end
    #set($macro.shouldCreateAssertEqualsCall = $macro.expectedValueRef || $macro.shouldStoreExpectedValue)
    #set($macro.shouldStoreActualValue = !$macro.shouldCreateAssertEqualsCall)
    @Test
    void test${StringUtils.capitalize(${method.name})}${method.overloadSuffix}() {
        ## Construct the source class if needed.
        #if($shouldCreateSourceClassInEachTestMethod)
            #initializeSourceClass()
        #end
        #if($macro.shouldStoreExpectedValue)
            #declareAndInitLocalVar($method.returnType, false)
            #set($macro.expectedValueRef = $method.returnType.testClassLocalFieldName)
        #end
        #if($macro.shouldStoreActualValue)
            def result = $macro.getterCallExpression;
        #end
        #if($macro.shouldCreateAssertEqualsCall)
            #assertEqualsCall($macro.expectedValueRef, $macro.getterCallExpression, $method.returnType);
        #end
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderSetterTest($method)
## Renders a test for the provided setter method.
## Param: $method - the method for which to render the test.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderSetterTest $method)
    #set($macro.qualifier = "#if($testInfo.method.static)${method.containingClass.canonicalNameOrName}#elseif($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    @Test
    void test${StringUtils.capitalize(${method.name})}${method.overloadSuffix}() {
        #if($shouldCreateSourceClassInEachTestMethod)
            #initializeSourceClass()
        #end
        #if($method.parameters.first.shouldStoreInReference)
            #declareAndInitLocalVarImpl($method.parameters.first, $method.parameters.first.initExpression, false)
        #end
        ${macro.qualifier}.#methodCall($method, false);
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## renderDoNothingTest($method)
## Renders a test for a given method that does nothing.
## Param: $method - the method for which to render the test method.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderDoNothingTest $method)
    @Test
    void test${StringUtils.capitalize(${method.name})}${method.overloadSuffix}() {
        #if(!$method.static && $shouldCreateSourceClassInEachTestMethod)
            #initializeSourceClass()
        #end
        #set($macro.qualifier = "#if($method.static)${method.containingClass.canonicalNameOrName}#elseif($sourceClass.enum)${sourceClass.canonicalNameOrName}.${sourceClass.enumFirstValue}#elseif($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
        ${macro.qualifier}.#methodCall($method, false);
    }
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeSourceClass()
## Renders code to initialize the source class.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeSourceClass)
    #set($macro.qualifier = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.leftSide = "#if($shouldCreateSourceClassInEachTestMethod) def ${macro.qualifier}#else${macro.qualifier}#end")
    #if(!$shouldUseInjectMocks)
        #if($sourceClassConstructor)
            #foreach($param in $sourceClassConstructor.parameters.filter('shouldStoreInReference').filterOut('shouldBeMocked'))
                #declareAndInitLocalVar($param, false)
            #end
            ${macro.leftSide} = new #methodCall($sourceClassConstructor, true) #if($sourceClass.abstract && !$sourceClass.sealed)$sourceClass.abstractClassBody#end;
        #else
            ${macro.leftSide} = $sourceClass.type.initExpression;
        #end
    #end
    #foreach($setterMethod in $setterMethodsToCall)
        #if($setterMethod.parameters.first.shouldStoreInReference && !$setterMethod.parameters.first.shouldBeMocked)
            #declareAndInitLocalVar($setterMethod.parameters.first, false)
        #end
        ${macro.qualifier}.#methodCall($setterMethod, true);
    #end
    #foreach($field in $fieldsToSetWithReflection)
        #if($field.shouldStoreInReference && !$field.shouldBeMocked)
            #declareAndInitLocalVar($field, false)
        #end
        #set($macro.argValue = false)
        #if(!$field.shouldStoreInReference)
            #set($macro.argValue = $field.initExpression)
        #elseif($field.shouldBeMocked)
            #set($macro.argValue = $field.testClassMemberName)
        #else
            #set($macro.argValue = $field.testClassLocalFieldName)
        #end
        #set($macro.quotedFieldName = $StringUtils.wrap($field.declaredName, '"'))
        org.springframework.test.util.ReflectionTestUtils.setField($sourceClass.testClassMemberName, $macro.quotedFieldName, $macro.argValue);
    #end
    #foreach($field in $packageLocalFieldsToSet)
        #if($field.shouldStoreInReference && !$field.shouldBeMocked)
            #declareAndInitLocalVar($field, false)
        #end
        #set($macro.argValue = false)
        #if(!$field.shouldStoreInReference)
            #set($macro.argValue = $field.initExpression)
        #elseif($field.shouldBeMocked)
            #set($macro.argValue = $field.testClassMemberName)
        #else
            #set($macro.argValue = $field.testClassLocalFieldName)
        #end
        ${macro.qualifier}.${field.declaredName} = $macro.argValue;
    #end
    #if(!$fieldsThatCannotBeSet.empty)
        // TODO: Set the following fields: $fieldsThatCannotBeSet.map('declaredName').limit(10).join(", ").
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## assertEqualsCall($expected, $actual, $type)
## Renders the assertEquals method call appropriate for the given parameters.
## Param: $expected - the value to use for the expected argument of the assertEquals method call.
## Param: $actual - the value to use for the actual argument of the assertEquals method call.
## Param: $type - the Type of the arguments; this is used to determine which assertEquals method to call.
##----------------------------------------------------------------------------------------------------------------------
#macro(assertEqualsCall $expected, $actual, $type)
    #if($StringUtils.equalsAny($type.canonicalName, 'double', 'java.lang.Double')) assertEquals($expected, $actual, 0.0001d) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'float', 'java.lang.Float')) assertEquals($expected, $actual, 0.0001f) #break
    #elseif($StringUtils.equalsAny($type.canonicalName, 'boolean', 'java.lang.Boolean')) assertFalse($actual) #break
    #else assert $expected == $actual #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderStubs($testInfo)
## Renders the stubs (when, doAnswer, doThrow, etc) for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderStubs $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #renderAbsentStub($di)
        #elseif($testInfo.shouldReturnEmpty($di))
            #renderEmptyStub($di)
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #renderEmptyIoStub($di)
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #renderBrokenIoStub($di)
        #elseif($testInfo.shouldThrowException($di))
            #renderExceptionStub($di, $testInfo.getExceptionToThrow($di))
        #elseif($testInfo.shouldReturnFailure($di))
            #renderFailureStub($di)
        #elseif(!$di.returnValueIgnored || $di.method.returnType.closeable || $di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable','java.lang.Runnable'))
            #renderPrimaryFlowStub($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($dis)
## Renders the primary flow stubs (when, doAnswer, etc) for the given dependency interactions.
## Param: $dis - the dependency interactions to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStubs $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowStub($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowStubs($di)
## Renders the primary flow stub (when, doAnswer, etc) for the given dependency interaction.
## Param: $di - the dependency interaction to render stubs for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.shouldRenderComment = $di.method.returnType.shouldStoreInReference || $di.method.parameters.containsAnyWithNonNull('type.initExpressionBeans.first'))
    #if($di.method.parameters.containsAnyWith('type.canonicalName', 'java.lang.Runnable'))
        #renderAnswerForRunnable($di)
    #elseif($di.method.parameters.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable'))
        #renderAnswerForCallable($di)
    #elseif($di.method.returnType)
        #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
        ## Declare a local variable for the return type if needed.
        #if($macro.shouldRenderComment)

            // Configure ${di.field.type.name}.${di.method.name}(...).
        #end
        #if($di.method.returnType.shouldStoreInReference)
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
        #foreach($param in $di.method.parameters)
            #if(!$param.type.initExpressionBeans.empty)
                #declareAndInitLocalVar($param, false)
                #set($param.shouldStoreInReference = true)
            #end
        #end
        #set($macro.returnTypeExpression = "#if($di.method.returnType.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.initExpression #end")
        #if($macro.hasInnerWildcardType)
            $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
        #else
            $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
        #end
        #if($macro.shouldRenderComment) $Newline #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForRunnable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Runnable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForRunnable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfRunnable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.lang.Runnable'))
    $doAnswer({InvocationOnMock invocation ->
        ((Runnable) invocation.getArguments()[$macro.indexOfRunnable]).run();
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(null);
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
            def settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(null);
            return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
            def mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
            $doReturn(null).$when(mockFuture).get();
            $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
        #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
        #else
            return null;
        #end
    }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAnswerForCallable($di)
## Renders the doAnswer(...) statement for the dependency interaction whose method takes in at least one Callable.
## Param: $di - the dependency interaction to render the doAnswer(...) statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAnswerForCallable $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.indexOfCallable = $di.method.parameters.indexOfAny('type.canonicalName', 'java.util.concurrent.Callable'))
    $doAnswer({InvocationOnMock invocation ->
        def callable = (Callable<?>) invocation.getArguments()[$macro.indexOfCallable];
        #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture'))
            return CompletableFuture.completedFuture(callable.call());
        #elseif($di.method.returnType.canonicalName == 'com.google.common.util.concurrent.ListenableFuture')
            def settableFuture = com.google.common.util.concurrent.SettableFuture.create();
            settableFuture.set(callable.call());
            return settableFuture;
        #elseif($di.method.returnType.canonicalName == 'java.util.concurrent.ScheduledFuture')
            def mockFuture = #mock('java.util.concurrent.ScheduledFuture.class');
            $doReturn(callable.call()).$when(mockFuture).get();
            $doReturn(true).$when(mockFuture).isDone();
            return mockFuture;
        #elseif($di.method.returnType)
            return $di.method.returnType.initExpression;
        #else
            return null;
        #end
    }).$when($macro.qualifier).#methodCall($di.method, false);
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExceptionStub($di, $exceptionToThrow)
## Configures the provided dependency interaction ($di) to throw the provided $exceptionToThrow.
## Param: $di - the dependency interaction to be configured to throw.
## Param: $exceptionToThrow - the exception the $di should throw.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExceptionStub $di, $exceptionToThrow)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.shouldRenderComment = $di.method.parameters.containsAnyWithNonNull('type.initExpressionBeans.first'))
    #if($macro.shouldRenderComment)

        // Configure ${di.field.type.name}.${di.method.name}(...).
    #end
    #foreach($param in $di.method.parameters)
        #if(!$param.type.initExpressionBeans.empty)
            #declareAndInitLocalVar($param, false)
            #set($param.shouldStoreInReference = true)
        #end
    #end
    #if($di.method.returnType)
        $when($macro.qualifier.#methodCall($di.method, false)).$thenThrow(${exceptionToThrow.type.canonicalNameOrName}.class);
    #else
        $doThrow(${exceptionToThrow.type.canonicalNameOrName}.class).$when($macro.qualifier).#methodCall($di.method, false);
    #end
    #if($macro.shouldRenderComment) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderAbsentStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderAbsentStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.shouldStoreInReference = !$di.method.inferredNullable && $di.method.returnType.shouldBeSpied)
    #set($macro.shouldRenderComment = $macro.shouldStoreInReference || $di.method.parameters.containsAnyWithNonNull('type.initExpressionBeans.first'))
    #if($macro.shouldRenderComment)

            // Configure ${di.field.type.name}.${di.method.name}(...).
    #end
    #if($macro.shouldStoreInReference)
        #if($di.method.returnType.shouldBeSpied)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.absentInitExpression, false)
        #end
    #end
    #foreach($param in $di.method.parameters)
        #if(!$param.type.initExpressionBeans.empty)
            #declareAndInitLocalVar($param, false)
            #set($param.shouldStoreInReference = true)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.absentInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldRenderComment) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, true, false, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyIoInitExpression, false)
        #end
    #end
    #foreach($param in $di.method.parameters)
        #if(!$param.type.initExpressionBeans.empty)
            #declareAndInitLocalVar($param, false)
            #set($param.shouldStoreInReference = true)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBrokenIoStub($di)
## Configures the provided dependency interaction ($di) to return either null or an absent value.
## Param: $di - the dependency interaction to be configured to return an absent value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBrokenIoStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.shouldStoreInReference = true)
    #if($macro.shouldStoreInReference)

        // Configure ${di.field.type.name}.${di.method.name}(...).
        #if($di.method.returnType.dtoBeanWithInputIoProperty)
            #declareAndInitLocalVarBeanWithAltIo($di.method.returnType, false, true, false)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.brokenIoInitExpression, false)
        #end
    #end
    #foreach($param in $di.method.parameters)
        #if(!$param.type.initExpressionBeans.empty)
            #declareAndInitLocalVar($param, false)
            #set($param.shouldStoreInReference = true)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.brokenIoInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldStoreInReference) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderEmptyStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderEmptyStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.emptyInitExpressionIsLong = $di.method.returnType.emptyInitExpression && $ClassUtils.removePackageQualifiers($di.method.returnType.emptyInitExpression).length() > 40)
    #set($macro.shouldStoreInReference = ($di.method.returnType.shouldStoreInReference && ($di.method.returnType.shouldBeMocked || $macro.emptyInitExpressionIsLong)) || $di.method.returnType.shouldBeSpied)
    #set($macro.shouldRenderComment = $macro.shouldStoreInReference || $di.method.parameters.containsAnyWithNonNull('type.initExpressionBeans.first'))
    #if($macro.shouldRenderComment)

        // Configure ${di.field.type.name}.${di.method.name}(...).
    #end
    #if($macro.shouldStoreInReference)
        #if($di.method.returnType.shouldBeSpied || $macro.emptyInitExpressionIsLong)
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.emptyInitExpression, false)
        #else
            #declareAndInitLocalVar($di.method.returnType, false)
        #end
    #end
    #foreach($param in $di.method.parameters)
        #if(!$param.type.initExpressionBeans.empty)
            #declareAndInitLocalVar($param, false)
            #set($param.shouldStoreInReference = true)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.emptyInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldRenderComment) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderFailureStub($di)
## Configures the provided dependency interaction ($di) to return an empty value.
## Param: $di - the dependency interaction to be configured to return an empty value.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderFailureStub $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.hasInnerWildcardType = $di.method.returnType.parameters.containsAnyWith('wildcard', true))
    #set($macro.isStandardFuture = $StringUtils.equalsAny($di.method.returnType.canonicalName, 'java.util.concurrent.Future', 'java.util.concurrent.CompletableFuture', 'java.util.concurrent.CompletionStage'))
    #set($macro.shouldStoreInReference = $di.method.returnType.shouldStoreInReference || $di.method.returnType.shouldBeSpied || ($macro.isStandardFuture && !$di.method.returnType.failureInitExpression) || !$di.method.returnType.failureInitExpressionBeans.empty)
    #set($macro.shouldRenderComment = $macro.shouldStoreInReference || $di.method.parameters.containsAnyWithNonNull('type.initExpressionBeans.first'))
    #if($macro.shouldRenderComment)

        // Configure ${di.field.type.name}.${di.method.name}(...).
    #end
    #if($macro.shouldStoreInReference)
        #if($macro.isStandardFuture && !$di.method.returnType.failureInitExpression)
            #declareAndInitCompletableFutureFailureCase($di.method.returnType)
        #else
            #declareAndInitLocalVarImpl($di.method.returnType, $di.method.returnType.failureInitExpression, false)
        #end
    #end
    #foreach($param in $di.method.parameters)
        #if(!$param.type.initExpressionBeans.empty)
            #declareAndInitLocalVar($param, false)
            #set($param.shouldStoreInReference = true)
        #end
    #end
    #set($macro.returnTypeExpression = "#if($macro.shouldStoreInReference)$di.method.returnType.testClassLocalFieldName#else $di.method.returnType.failureInitExpression #end")
    #if($macro.hasInnerWildcardType)
        $doReturn($macro.returnTypeExpression).$when($macro.qualifier).#methodCall($di.method, false);
    #else
        $when($macro.qualifier.#methodCall($di.method, false)).$thenReturn($macro.returnTypeExpression);
    #end
    #if($macro.shouldRenderComment) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVar($param, $addNewlineAfterBean)
## Declares and initializes a local variable for $param. If $param is a DTOBean, Squaretest will initialize its
## properties. Squaretest also initializes any DTOBeans required for the $param's initialization expression.
## Param: $param - the Type or Variable to declare and initialize.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVar $param, $addNewlineAfterBean)
    #declareAndInitLocalVarImpl($param, false, $addNewlineAfterBean)
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarImpl($param, $addNewlineAfterBean)
## The implementation for declareAndInitLocalVar(..).
## Param: $param - the Type or Variable to declare and initialize.
## Param: $initExpressionToUse - The init expression to use inline for the $param.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarImpl $param, $initExpressionToUse, $addNewlineAfterBean)
    #set($macro.isOrHasBean = $param.type.dtoBean || !$param.type.initExpressionBeans.empty)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    #if($initExpressionToUse)
        #if($initExpressionToUse == $param.type.defaultFailureInitExpression && !$param.type.failureInitExpressionBeans.empty && !$param.type.dtoBean)
            #foreach($beanType in $param.type.failureInitExpressionBeans)
                ## Declare the local field for the bean and initialize it.
                #declareAndInitLocalVar($beanType, false)
            #end
            #set($macro.failureInitExpression = $param.type.createFailureInitExpressionWithLocalFieldBeans($param.type.failureInitExpressionBeans))
            def $param.testClassLocalFieldName = $macro.failureInitExpression;
        #else
            def $param.testClassLocalFieldName = $initExpressionToUse;
        #end
    #elseif($param.type.dtoBean)
        def $param.testClassLocalFieldName = $param.type.initExpression;
        #renderBeanSetupCodeForVar($param, false, false)
        #if($addNewlineAfterBean) $Newline #end
    #elseif(!$param.type.initExpressionBeans.empty)
        ## The parameter's initExpression has one or more beans; e.g. the bean in Optional.of(bean).
        ## Declare and init the beans first.
        #foreach($beanType in $param.type.initExpressionBeans)
            ## Declare the local field for the bean and initialize it.
            #declareAndInitLocalVar($beanType, false)
        #end
        #set($param.type.initExpression = $param.type.createInitExpressionWithLocalFieldBeans($param.type.initExpressionBeans))
        def $param.testClassLocalFieldName = $param.type.initExpression;
    #else
        def $param.testClassLocalFieldName = $param.type.initExpression;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitLocalVarBeanWithAltIo($param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean)
## Declares and initializes a bean using an alternate IO init expression for its IO property.
## Param: $param - the Type or Variable to declare and initialize.
## Param: $shouldUseEmptyIo - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $addNewlineAfterBean - boolean indicating whether a newline should be added after bean init code (or false).
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitLocalVarBeanWithAltIo $param, $shouldUseEmptyIo, $shouldUseBrokenIo, $addNewlineAfterBean)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    def $param.testClassLocalFieldName = $param.type.initExpression;
    #renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #if($addNewlineAfterBean) $Newline #end
#end

##----------------------------------------------------------------------------------------------------------------------
## declareAndInitCompletableFutureFailureCase($param)
## Declares and initializes a Future or CompletableFuture with an Exception result. This is needed to support Java 8.
## In Java 9+ CompletableFuture.failedFuture(exception) is used to construct the future with an exception result.
## Param: $param - the Type or Variable to declare and initialize.
##----------------------------------------------------------------------------------------------------------------------
#macro(declareAndInitCompletableFutureFailureCase $param)
    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($param))
    def $param.testClassLocalFieldName = new java.util.concurrent.CompletableFuture<>();
    ${param.testClassLocalFieldName}.completeExceptionally(new java.lang.Exception("message"));
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeForVar($param, $shouldUseEmptyIo, $shouldUseBrokenIo)
## Renders the code necessary to configure the provided bean.
## Param: $param - the Type or Variable for which to render the bean setup code.
## Param: $shouldUseEmptyIo - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeForVar $param, $shouldUseEmptyIo, $shouldUseBrokenIo)
    #set($macro.canonicalNamesInCallStack = {})
    #set($macro.canonicalNamesInCallStack[$param.type.canonicalName] = true)
    #set($macro.numberOfSettersCalled = $MutableInt.create(0))
    #if($param.type.shouldOnlySetUsedProperties)
        #set($macro.minSetters = 0)
    #else
        #set($macro.minSetters = $minNumberOfSettersToCall)
    #end
    #renderBeanSetupCodeRecursively($param, $BeanContext.create($param, $macro.minSetters, $maxNumberOfSettersToCall), $shouldUseEmptyIo, $shouldUseBrokenIo, $macro.canonicalNamesInCallStack, $macro.numberOfSettersCalled)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderBeanSetupCodeRecursively(..)
## This should only be called from the #renderBeanSetupCodeForVar() macro.
## Renders the code necessary to configure the provided bean and its properties that are beans or lists of beans.
## Param: $typeOrVariable - the Type or Variable for which to render the bean setup code.
## Param: $beanContext - the context describing how to initialize the top level bean and its sub beans.
## Param: $shouldUseEmptyIo - boolean indicating whether or not to initialize the IO property to the empty IO variant.
## Param: $shouldUseBrokenIo - boolean indicating whether or not to initialize the IO property to the broken IO variant.
## Param: $canonicalNamesInCallStack - the canonical names of beans in the recursive init call stack. This is used to
##        avoid infinite recursive loops.
## Param: $numberOfSettersCalled - MutableInt containing the total number of setters called in this recurisve call.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderBeanSetupCodeRecursively $typeOrVariable, $beanContext, $shouldUseEmptyIo, $shouldUseBrokenIo, $canonicalNamesInCallStack, $numberOfSettersCalled)
    #set($macro.beanClass = $ClassUtils.resolveBean($beanContext, $typeOrVariable))
    #if(!$macro.beanClass)#break #end
    #set($macro.beanClass.testClassLocalFieldName = $typeOrVariable.testClassLocalFieldName)
    #set($macro.preferredSetters = $macro.beanClass.preferredInitMethods)
    #foreach($setter in $macro.preferredSetters)
        #if($numberOfSettersCalled.intValue() >= $beanContext.maxSettersToCall)#break #end
        #set($_ = $numberOfSettersCalled.increment())
        #if($setter.jaxbListGetter)
            #set($macro.param = $setter.returnType)
        #else
            #set($macro.param = $setter.parameters.first)
        #end
        #if($macro.param.type.generic && $typeOrVariable.type.parameters.size() == 1 && !$typeOrVariable.type.parameters.first.generic)
            #set($macro.param = $typeOrVariable.type.parameters.first)
        #end
        #if($macro.param.type.dtoBean)
            #if(!$canonicalNamesInCallStack[$macro.param.type.canonicalName])
                #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($macro.param))
                def $macro.param.testClassLocalFieldName = $macro.param.initExpression;
                ## Store the beans cannonical name in map to avoid entering a recursive loop.
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = true)
                #renderBeanSetupCodeRecursively($macro.param, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                #set($canonicalNamesInCallStack[$macro.param.type.canonicalName] = false)
                #set($macro.param.shouldStoreInReference = true)
            #else
                #set($macro.param.shouldStoreInReference = false)
            #end
        #elseif(!$macro.param.type.initExpressionBeans.empty)
            ## The setter's param's initExpression contains at least one bean.
            #foreach($beanType in $macro.param.type.initExpressionBeans)
                #if(!$canonicalNamesInCallStack[$beanType.canonicalName])
                    #set($_ = $CodeStyleUtils.updateLocalFieldNameWithMethodScope($beanType))
                    def $beanType.testClassLocalFieldName = $beanType.initExpression;
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = true)
                    #renderBeanSetupCodeRecursively($beanType, $beanContext, false, false, $canonicalNamesInCallStack, $numberOfSettersCalled)
                    #set($canonicalNamesInCallStack[$beanType.canonicalName] = false)
                    #set($beanType.shouldStoreInReference = true)
                #else
                    #set($beanType.shouldStoreInReference = false)
                #end
            #end
            #set($macro.param.type.initExpression = $macro.param.type.createInitExpressionWithLocalFieldBeans($macro.param.type.initExpressionBeans.filter('shouldStoreInReference')))
            #set($macro.param.shouldStoreInReference = false)
        #else
            #set($macro.param.shouldStoreInReference = false)
        #end
        #if($setter.jaxbListGetter)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}().addAll($macro.param.type.initExpression);
        #elseif($shouldUseEmptyIo && $macro.param.type.emptyIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.emptyIoInitExpression);
        #elseif($shouldUseBrokenIo && $macro.param.type.brokenIoInitExpression)
            ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.brokenIoInitExpression);
        #else
            #if($macro.param.shouldStoreInReference)
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.testClassLocalFieldName);
            #else
                ${macro.beanClass.testClassLocalFieldName}.${setter.name}($macro.param.type.initExpression);
            #end
        #end
    #end
    #renderExtraBeanSetupCode($macro.beanClass)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraBeanSetupCode($beanSourceClass)
## Renders any extra statements needed to initialize the instance of the $beanSourceClass.
## Param: $beanSourceClass - the SourceClass for the bean to render extra initialization code for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraBeanSetupCode $beanSourceClass)
    #if($StringUtils.equalsAny($beanSourceClass.type.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        def spyS3Object = spy(new com.amazonaws.services.s3.model.S3Object());
        spyS3Object.setBucketName("bucketName");
        spyS3Object.setKey("key");
        spyS3Object.setObjectContent(new java.io.ByteArrayInputStream("objectContent".getBytes()));
        ${beanSourceClass.testClassLocalFieldName}.setS3Object(spyS3Object);
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderVerifyStatements($testInfo)
## Renders verify statements for the given test case.
## Param: $testInfo - information about which case this test should cover.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderVerifyStatements $testInfo)
    #if(!$generateStubsAndVerifyStatements)#break #end
    #foreach($di in $testInfo.mockedDIs)
        #if($testInfo.shouldReturnAbsent($di))
            #if($di.method.inferredNullable && $di.method.returnType.shouldBeSpied)
                ## Do nothing. The DI normally returns a closeable. It's returning null in this case, so no verify(..) is needed.
            #elseif($di.returnValueIgnored || $di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmpty($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnEmptyIo($di))
            #if($di.method.returnType.shouldBeSpied || $di.returnValueIgnored)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldReturnBrokenIo($di))
            #if($di.method.returnType.shouldBeSpied)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #elseif($testInfo.shouldThrowException($di))
            ## Do nothing.
        #elseif($testInfo.shouldReturnFailure($di))
            #if($di.returnValueIgnored || $di.method.returnType.closeable)
                #renderPrimaryFlowVerifyStatement($di)
            #end
        #else
            #renderPrimaryFlowVerifyStatement($di)
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatements($dis)
## Renders primary flow verify statements for the given dependency interactions ($dis).
## Param: $dis - the dependency interactions to render the primary flow verify statements for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatements $dis)
    #foreach($di in $dis)
        #renderPrimaryFlowVerifyStatement($di)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderPrimaryFlowVerifyStatement($di)
## Renders primary flow verify statement for the given dependency interactions ($di).
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderPrimaryFlowVerifyStatement $di)
    #set($macro.sourceVar = $di.field.possibleSourceVariables.intersection($dependencies).first)
    #set($macro.sourceMemberRef = "#if($shouldCreateSourceClassInEachTestMethod)${sourceClass.testClassLocalFieldName}#else${sourceClass.testClassMemberName}#end")
    #set($macro.qualifier = "#if($packageLocalFieldsWithInlineMocks.contains($macro.sourceVar))${macro.sourceMemberRef}.${macro.sourceVar.declaredName}#else $macro.sourceVar.testClassMemberName #end")
    #set($macro.shouldConfirmClose = $di.method.returnType && $di.method.returnType.closeable && $di.method.returnType.shouldStoreInReference)
    #set($macro.shouldRenderComment = (!$di.method.returnType || $di.returnValueIgnored) && !$macro.shouldConfirmClose && $di.method.parameters.containsAnyWithNonNull('type.initExpressionBeans.first'))
    #if($macro.shouldRenderComment)

        // Confirm ${di.field.type.name}.${di.method.name}(...).
        #foreach($param in $di.method.parameters)
            #if(!$param.type.initExpressionBeans.empty)
                #declareAndInitLocalVar($param, false)
                #set($param.shouldStoreInReference = true)
            #end
        #end
    #end
    #if($macro.shouldConfirmClose)
        #if($shouldUseMockitoBdd)
            then($di.method.returnType.testClassLocalFieldName).should().close();
        #else
            verify($di.method.returnType.testClassLocalFieldName).close();
        #end
    #elseif(!$di.method.returnType || $di.returnValueIgnored)
        #if($shouldUseMockitoBdd)
            then($macro.qualifier).should().#methodCall($di.method, false);
        #else
            verify($macro.qualifier).#methodCall($di.method, false);
        #end
    #end
    #renderExtraVerifyStatements($di)
#end

##----------------------------------------------------------------------------------------------------------------------
## renderExtraVerifyStatements($di)
## Renders any extra verify statements needed for the provided dependency interaction.
## Param: $di - the dependency interactions to render the primary flow verify statement for.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderExtraVerifyStatements $di)
    #if($StringUtils.equalsAny($di.method.returnType.canonicalName, 'com.amazonaws.services.s3.model.PresignedUrlDownloadResult'))
        #if($shouldUseMockitoBdd)
            then(spyS3Object).should().close();
        #else
            verify(spyS3Object).close();
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## methodCall($method, $assumeMocksAreStoredInMembers)
## Renders an expression to call the given method. This does not include any qualifiers required to reference
## the method.
## Param: $method - the method or constructor for which to render the call-expression.
## Param: $assumeMocksAreStoredInMembers - assumes the arguments are stored in member fields instead of local fields.
## Note: This macro uses multiline comments: #* and *# to avoid adding newlines.
##----------------------------------------------------------------------------------------------------------------------
#macro(methodCall $method, $assumeMocksAreStoredInMembers)
    #if($method.shouldUseLastParam)
        #set($macro.params = $method.parameters)
    #else
        #set($macro.endIndexExclusive = $method.parameters.size() - 1)
        #set($macro.params = $method.parameters.subList(0, $macro.endIndexExclusive))
    #end#*
    *#${method.name}#if($method.constructor && $sourceClass.hasGenerics)<>#end#*
    *#(#foreach($param in $macro.params)
        #if($param.props.shouldUseEqMatcher)
            #set($macro.prefix = 'eq(')
            #set($macro.suffix = ')')
        #else
            #set($macro.prefix = '')
            #set($macro.suffix = '')
        #end#*
        *##if(!$param.shouldStoreInReference)#*
            *#${macro.prefix}${param.initExpression}${macro.suffix}#*
        *##elseif($assumeMocksAreStoredInMembers && $param.shouldBeMocked)#*
            *#${macro.prefix}${param.testClassMemberName}${macro.suffix}#*
        *##else#*
            *#${macro.prefix}${param.testClassLocalFieldName}${macro.suffix}#*
        *##end#*
        *##if($foreach.hasNext),#end#*
    *##end)#*
*##end

##----------------------------------------------------------------------------------------------------------------------
## determineTestCaseSuffix($testInfo)
## Determines the suffix to use for the given test case and stores the result in $testCaseSuffix.
## Param: $testInfo - information about which case this test should cover.
## Out:   $testCaseSuffix - the suffix to use for this test case.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineTestCaseSuffix $testInfo)
    #set($macro.disToUse = $testInfo.method.dependencyInteractions.satisfiedBy($dependencies.filter('shouldBeMocked')))
    #if($testInfo.subjectDi)
        #if($macro.disToUse.filterOutItemsWithSameSourceVar($testInfo.subjectDi).containsAnyWith('field.type.name', $testInfo.subjectDi.field.type.name))
            #set($macro.fieldName = "$StringUtils.capitalize($testInfo.subjectDi.field.declaredNameWithoutPrefix)")
        #else
            #set($macro.fieldName = "${testInfo.subjectDi.field.type.name}")
        #end
        #if($macro.disToUse.filterItemsWithSameSourceVar($testInfo.subjectDi).size() > 1)
            #set($macro.descriptionPart1 = "_${macro.fieldName}$StringUtils.capitalize($testInfo.subjectDi.method.name)${testInfo.subjectDi.overloadSuffix}")
        #else
            #set($macro.descriptionPart1 = "_${macro.fieldName}")
        #end
    #end
    #if($testInfo.paramWithEmptyIo)
        #set($testCaseSuffix = '_Empty' + $StringUtils.capitalize($testInfo.paramWithEmptyIo.declaredName))
    #elseif($testInfo.paramWithBrokenIo)
        #set($testCaseSuffix = '_Broken' + $StringUtils.capitalize($testInfo.paramWithBrokenIo.declaredName))
    #elseif($testInfo.subjectDiExceptionToThrow)
        #set($testCaseSuffix = "${macro.descriptionPart1}Throws${testInfo.subjectDiExceptionToThrow.type.name}")
    #elseif($testInfo.subjectDiReturnsFailure)
        #if($StringUtils.equals($testInfo.subjectDi.method.returnType.failureInitExpression, 'true'))
            #set($macro.returnSuffix = 'ReturnsTrue')
        #elseif($StringUtils.equals($testInfo.subjectDi.method.returnType.failureInitExpression, 'false'))
            #set($macro.returnSuffix = 'ReturnsFalse')
        #elseif($StringUtils.containsIgnoreCase($testInfo.subjectDi.method.returnType.failureInitExpression, 'Error'))
            #set($macro.returnSuffix = 'ReturnsError')
        #else
            #set($macro.returnSuffix = 'ReturnsFailure')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.subjectDiReturnsEmpty)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoItems')
    #elseif($testInfo.subjectDiReturnsEmptyIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsNoContent')
    #elseif($testInfo.subjectDiReturnsBrokenIo)
        #set($testCaseSuffix = "${macro.descriptionPart1}" + 'ReturnsBrokenIo')
    #elseif($testInfo.subjectDiReturnsAbsent)
        #if($testInfo.subjectDi.method.inferredNullable)
            #set($macro.returnSuffix = 'ReturnsNull')
        #elseif($testInfo.subjectDi.method.returnType.optional)
            #set($macro.returnSuffix = 'ReturnsAbsent')
        #else
            #set($macro.returnSuffix = 'ReturnsNoItem')
        #end
        #set($testCaseSuffix = "${macro.descriptionPart1}" + $macro.returnSuffix)
    #elseif($testInfo.expectedException)
        #set($testCaseSuffix = "_Throws${testInfo.expectedException.type.name}")
    #else
        #set($testCaseSuffix = '')
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## Generates an inline mock expression to create a mock for type: $classToMock in a way that is consistent with the
## $useStaticImportForInitMocks quick setting.
## Param: $classToMock - the name or canonical name of the class to mock.
##----------------------------------------------------------------------------------------------------------------------
#macro(mock $classToMock)
    #if($useStaticImportForInitMocks) mock($classToMock) #else Mockito.mock($classToMock) #end
#end

##----------------------------------------------------------------------------------------------------------------------
## renderImportsForMatchers()
## Renders import statements for the mockito matchers; i.e. any(), eq(), etc.
## Matchers will be imported from org.mockito.ArgumentMatchers if it is available on the test classpath or if none of
## the mockito classes are on the test classpath. Otherwise, if org.mockito.Matchers is present on the classpath and
## org.mockito.ArgumentMatchers is not, Squaretest will import the matchers from org.mockito.Matchers.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderImportsForMatchers)
    #set($macro.matcherCanonicalName = 'org.mockito.ArgumentMatchers')
    #if((!$ClassUtils.isInTestClasspath($macro.matcherCanonicalName))
        && $ClassUtils.isInTestClasspath('org.mockito.Matchers'))
        #set($macro.matcherCanonicalName = 'org.mockito.Matchers')
    #end
    import static ${macro.matcherCanonicalName}.any;
    import static ${macro.matcherCanonicalName}.anyInt;
    import static ${macro.matcherCanonicalName}.anyString;
    import static ${macro.matcherCanonicalName}.eq;
#end

##----------------------------------------------------------------------------------------------------------------------
## renderImportsForAndroidComponents()
## Determines which version of the Android test framework is on the classpath and renders appropriate import statements.
##----------------------------------------------------------------------------------------------------------------------
#macro(renderImportsForAndroidComponents)
    #if($ClassUtils.isInTestClasspath('androidx.test.filters.SmallTest'))
        import androidx.test.filters.SmallTest;
        import androidx.test.filters.LargeTest;
        import androidx.test.rule.ActivityTestRule;
        #if($ClassUtils.isInTestClasspath('androidx.test.ext.junit.runners.AndroidJUnit4'))
            import androidx.test.ext.junit.runners.AndroidJUnit4;
        #else
            import androidx.test.runner.AndroidJUnit4;
        #end
        #if($ClassUtils.isInTestClasspath('androidx.test.platform.app.InstrumentationRegistry'))
            import androidx.test.platform.app.InstrumentationRegistry;
        #else
            import androidx.test.InstrumentationRegistry;
        #end
    #else
        import android.support.test.filters.SmallTest;
        import android.support.test.filters.LargeTest;
        import android.support.test.rule.ActivityTestRule;
        import android.support.test.runner.AndroidJUnit4;
        import android.support.test.InstrumentationRegistry;
    #end
    #if($hasActivityScenario)
        import androidx.test.core.app.ActivityScenario;
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeTemplateDataModel()
## Updates mutable fields in $sourceClass based on the Quick Settings at the top of the file and the architype of the
## source class. This also sets additional variables used in the rendering logic. Using a macro to prepare the data
## model separates the rendering logic from the configuration and class architype detection logic. This keeps the
## rendering logic simple and easy to modify.
##
## Global Variables Set by #initializeTemplateDataModel():
##
##   Variables Used In Test Class Setup Code:
##   $dependencies                  List<Variable> containing all fields the test class should provide for the
##                                  instance of the source class.
##   $mockMembers                   contains dependencies that should be mocked and stored in test class members.
##   $shouldRenderSourceClassMember boolean indicating whether or not an instance of the source class should be
##                                  created and stored in a member of the test class.
##   $shouldUseInjectMocks          boolean indicating whether or not @InjectMocks should be used to provide
##                                  dependencies to the instance of the source class.
##   $shouldRenderMockitoCloseable  boolean indicating whether a mockitoCloseable should be rendered.
##   $shouldRenderSetupMethod       boolean indicating whether a setup method should be rendered.
##   $shouldRenderTearDownMethod    boolean indicating whether a tear down method should be rendered.
##   $hasOpenMocksMethod            boolean indiciating whether the Mockito openMocks(..) method is available.
##   $initMocksMethodName           String containing either initMocks or openMocks depending on the test classpath.
##   $hasReflectionTestUtils        boolean indicating whether Spring ReflectionTestUtils is on the test classpath.
##   $hasAssertThrows               boolean indicating whether Assert.assertThrows(..) is on the test classpath.
##                                  This is available in JUnit 4.13 and higher.
##   $androidActivity               boolean indicating whether the source class is an Android Activity.
##   $hasActivityScenario           boolean indicating whether ActivityScenario is available on the test classpath.
##   $shouldUseAndroidRule          boolean indicating whether an ActivityTestRule is needed.
##   $methodsToTest                 FluentList<Method> containing the methods that should be tested.
##
##   Variables Used In Source Class Initialization:
##   $shouldCreateSourceClassInEachTestMethod boolean indicating whether the source class should be constructed in each
##                                  test method as opposed to the setup(..) method.
##   $sourceClassConstructor        The constructor that should be used to construct the source class.
##   $setterMethodsToCall           The setter methods that should be used to initialize the source class.
##   $packageLocalFieldsToSet       The package local fields that should be set to initialize the source class.
##   $packageLocalFieldsWithInlineMocks subset of $packageLocalFieldsToSet that contains package local fields that are
##                                  set to inline mocks.
##   $fieldsToSetWithReflection     Source class members that should be set via reflection to initialize the source
##                                  class.
##   $fieldsThatCannotBeSet         Source class members that Squaretest does not know how to set.
##
##   Mockito Variables Set Based On $shouldUseMockitoBdd:
##   $doAnswer                      Contains either 'doAnswer' or 'willAnswer'
##   $doReturn                      Contains either 'doReturn' or 'willReturn'
##   $thenReturn                    Contains either 'thenReturn' or 'willReturn'
##   $when                          Contains either 'when' or 'given'
##   $doThrow                       Contains either 'doThrow' or 'willThrow'
##   $thenThrow                     Contains either 'thenThrow' or 'willThrow'
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeTemplateDataModel)
    ## Determine information about JUnit and Mockito versions on the test classpath.
    #set($hasOpenMocksMethod = false)
    #set($initMocksMethodName = 'initMocks')
    #set($macro.mockitoAnnotationsSourceClass = $ClassUtils.resolveClass('org.mockito.MockitoAnnotations'))
    #if($macro.mockitoAnnotationsSourceClass && $macro.mockitoAnnotationsSourceClass.methods.containsAnyWith('name', 'openMocks'))
        #set($hasOpenMocksMethod = true)
        #set($initMocksMethodName = 'openMocks')
    #end
    #set($hasReflectionTestUtils = $ClassUtils.isInTestClasspath('org.springframework.test.util.ReflectionTestUtils'))
    ## Determine if we have Assert.assertThrows(..).
    #set($macro.assertClass = $ClassUtils.resolveClass('org.junit.Assert'))
    #if($macro.assertClass && $macro.assertClass.methods.containsAnyWith('name', 'assertThrows'))
        #set($hasAssertThrows = true)
    #else
        #set($hasAssertThrows = false)
    #end
    #set($androidActivity = $sourceClass.allSuperTypes.contains('android.app.Activity'))
    #set($hasActivityScenario = $ClassUtils.isInTestClasspath('androidx.test.core.app.ActivityScenario'))
    #set($shouldUseAndroidRule = $androidActivity && !$hasActivityScenario)
    #set($methodsAlreadyTested = {})
    #set($getterSetterTestNamesUsed = {})
    #if($shouldUseMockitoBdd)
        #set($doAnswer = 'willAnswer')
        #set($doReturn = 'willReturn')
        #set($thenReturn = 'willReturn')
        #set($when = 'given')
        #set($doThrow = 'willThrow')
        #set($thenThrow = 'willThrow')
    #else
        #set($doAnswer = 'doAnswer')
        #set($doReturn = 'doReturn')
        #set($thenReturn = 'thenReturn')
        #set($when = 'when')
        #set($doThrow = 'doThrow')
        #set($thenThrow = 'thenThrow')
    #end
    #determineDependenciesAndMethods()
    #updateDependenciesWithQuickSettings()
    #askUserToConfirmSettingsIfNeeded()
    #updateDependenciesWithUserChoices()
    #computeFinalRenderingParameters()
    #initializeMethodParamsWithQuickSettings()
    #initializeMethodReturnTypes()
    #initializeDependencyInteractionMethodParams()
#end

##----------------------------------------------------------------------------------------------------------------------
## determineDependenciesAndMethods()
## Determines the source class dependencies and methods that can be tested.
## This macro sets the following variables.
##   $sourceClassConstructor the constructor to use to provide the dependencies to the source class.
##   $dependencies           the soruce class dependencies
##   $possibleDependencies   possible source class dependencies
##   $methodsThatCanBeTested the methods in the source class and super classes that can be tested.
##   $canCreateSourceClassInEachTestMethod boolean indicating whether we can construct the source class in each test
##                                         method.
##   $shouldCreateSourceClassInEachTestMethod boolean indicating whether we should construct the source class in each
##                                            test method.
##----------------------------------------------------------------------------------------------------------------------
#macro(determineDependenciesAndMethods)
    #set($DependencyAnnotations = ['Inject', 'Autowired', 'Resource', 'PersistenceContext', 'EJB', 'Context', 'Value', 'Reference'])
    #set($lifecycleMethodsToExclude =
        ['onCreate', 'onStart', 'onRestart', 'onAttach', 'onCreateView', 'onActivityCreated',
            'onResume', 'onPause', 'onStop', 'onDestroyView', 'onDestroy', 'onDetach'])
    #set($dependencies = $FluentList.of())
    #set($possibleDependencies = $FluentList.of())
    #set($methodsThatCanBeTested = $FluentList.of())
    #set($sourceClassConstructor = $Null)
    #set($canCreateSourceClassInEachTestMethod = false)
    #set($shouldCreateSourceClassInEachTestMethod = false)
    #if($androidActivity)
        #set($methodsThatCanBeTested = $sourceClass.allNonObjectLowestOverrideMethods.filter('visibleToTestClass').filter('static'))
        #foreach($method in $methodsThatCanBeTested)
            #if($method.writable && $method.inMainSourceClass)
                #set($method.shouldTest = true)
            #end
        #end
        #break($macro)
    #end
    #if($sourceClass.enum)
        #set($methodsThatCanBeTested = $sourceClass.allNonObjectLowestOverrideMethods.filter('visibleToTestClass').filterOut2('name', $lifecycleMethodsToExclude))
        #foreach($method in $methodsThatCanBeTested)
            #if($method.writable && $method.inMainSourceClass)
                #set($method.shouldTest = true)
            #end
        #end
        #break($macro)
    #end
    #if($sourceClass.instanceMethods.empty && !$sourceClass.staticMethods.filter('visibleToTestClass').empty)
        #set($methodsThatCanBeTested = $sourceClass.allNonObjectLowestOverrideMethods.filter('visibleToTestClass').filter('static'))
        #foreach($method in $methodsThatCanBeTested)
            #if($method.writable && $method.inMainSourceClass)
                #set($method.shouldTest = true)
            #end
        #end
        #break($macro)
    #end
    #if($sourceClass.abstract)
        #if(!$sourceClass.packageVisibleStaticCreatorMethods.empty)
            #set($methodsThatCanBeTested = $sourceClass.allNonObjectLowestOverrideMethods.filter('visibleToTestClass').filter('static'))
            #foreach($method in $methodsThatCanBeTested)
                #if($method.writable && $method.inMainSourceClass)
                    #set($method.shouldTest = true)
                #end
            #end
            #break($macro)
        #end
    #end
    #if(!$sourceClass.preferredConstructor)
        #if(!$sourceClass.packageVisibleStaticCreatorMethods.empty && !$sourceClass.singleton)
            #set($methodsThatCanBeTested = $sourceClass.allNonObjectLowestOverrideMethods.filter('visibleToTestClass').filter('static'))
            #foreach($method in $methodsThatCanBeTested)
                #if($method.writable && $method.inMainSourceClass)
                    #set($method.shouldTest = true)
                #end
            #end
            #break($macro)
        #end
    #end
    #if($sourceClass.preferredConstructor)
        #set($_ = $dependencies.addAll($sourceClass.preferredConstructor.parameters))
        #set($sourceClassConstructor = $sourceClass.preferredConstructor)
        ## Find fields that are not satisfied by the constructor, but are dependencies.
        #foreach($field in $sourceClass.instanceFields)
            #if($field.possibleSourceVariables.containsAny($dependencies))
                ## Do nothing. We already provided a value to this dependency.
            #elseif($field.hasAnnotation($DependencyAnnotations))
                #if($field.setters.first)
                    #set($macro.setterParam = $field.setters.first.parameters.first)
                    #set($_ = $dependencies.add($macro.setterParam))
                #else
                    #set($_ = $dependencies.add($field))
                #end
            #elseif($field.setters.containsAnyWithAnnotation($DependencyAnnotations))
                #set($macro.setterParam = $field.setters.filterItemsWithAnnotation($DependencyAnnotations).first.parameters.first)
                #set($_ = $dependencies.add($macro.setterParam))
            #elseif($field.setters.first && !$field.getters.first)
                ## We have a setter with no corresponding getter. This is likely used for dependency injection.
                #set($_ = $dependencies.add($field.setters.first.parameters.first))
            #end
        #end
        ## Find fields that are not satisfied by the constructor, but might be dependencies.
        #foreach($field in $sourceClass.instanceFields)
            #if($field.possibleSourceVariables.containsAny($dependencies))
                ## Do nothing. We already provided a value to this field.
            #elseif($field.setters.first)
                #set($macro.setterParam = $field.setters.first.parameters.first)
                #set($_ = $possibleDependencies.add($macro.setterParam))
                #set($macro.setterParam.shouldBeMocked = false)
            #else
                #set($_ = $possibleDependencies.add($field))
                #set($field.shouldBeMocked = false)
            #end
        #end
    #elseif($sourceClass.singleton)
        #set($sourceClass.type.initExpression = $sourceClass.singletonAccessExpression)
    #end
    ## Determine the methods that can be tested.
    #foreach($method in $sourceClass.allNonObjectLowestOverrideMethods.filter('visibleToTestClass').filterOut('abstract').filterOut2('name', $lifecycleMethodsToExclude))
        #set($_ = $methodsThatCanBeTested.add($method))
    #end
    ## Mark methods that we will test by default.
    #set($macro.sourceClassHasAtLeastOneMethod = !$sourceClass.methods.filter('visibleToTestClass').filterOut('abstract').filterOut2('name', $lifecycleMethodsToExclude).empty)
    #foreach($method in $methodsThatCanBeTested)
        #if(($method.inMainSourceClass || !$macro.sourceClassHasAtLeastOneMethod) && $method.writable)
            #set($method.shouldTest = true)
        #end
    #end
    ## Determine if we can offer the option to construct the source class in each test method.
    #if($dependencies.filter('member').filter('private').empty)
        #set($canCreateSourceClassInEachTestMethod = true)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodReturnTypes()
## Sets the returnType.testClassLocalFieldName of each method to 'expectedResult'.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodReturnTypes)
    #foreach($method in $sourceClass.allMethods)
        #if($method.returnType)
            #if($sourceClass.packageVisibleStaticCreatorMethods.contains($method))
                #set($method.returnType.testClassLocalFieldName = 'result')
            #else
                #set($method.returnType.testClassLocalFieldName = 'expectedResult')
            #end
            #if($method.getter || $method.setter || $method.jaxbListGetter)
                #foreach($beanType in $method.returnType.initExpressionBeans)
                    #set($beanType.shouldOnlySetUsedProperties = true)
                #end
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeMethodParamsWithQuickSettings()
## Sets mutable fields on the method parameters based on Quick Settings.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeMethodParamsWithQuickSettings)
    #foreach($method in $sourceClass.allMethods)
    #foreach($param in $method.parameters)
        #if($dependencies.contains($param))
            ## Do nothing.
        #elseif($method.setter && !$method.targetField.getters.empty)
            #set($param.type.shouldOnlySetUsedProperties = true)
            #set($param.shouldStoreInReference = true)
            #set($param.type.shouldBeMocked = false)
        #elseif(($param.type.generic && $sourceClass.packageVisibleStaticCreatorMethods.contains($method)) || $method.doesNothing)
            ## Use inline args for generic types in static creator methods; e.g. Pair.of(left, right), ImmutableList.of(T...).
            #set($param.shouldStoreInReference = false)
        #elseif($useMocksForListenerAndCallbackParameters
            && $param.type.mockable
            && ($StringUtils.endsWithIgnoreCase($param.declaredName, "listener")
                || $StringUtils.endsWithIgnoreCase($param.declaredName, "callback")))
            ## If useMocksForListenerAndCallbackParameters is set it takes precedence over any initExpressionOverrides.
            #if($param.used)
                #useInlineMockForParam($param)
                #set($param.shouldStoreInReference = true)
            #else
                #set($param.shouldStoreInReference = false)
            #end
        #elseif(!$param.used && $param.type.initExpression == 'null')
            #set($param.shouldStoreInReference = false)
        #elseif($initExpressionOverrides.containsKey($param.type.canonicalName))
            ## Check the initExpressionOverrides.
            #set($macro.initExpressionOverride = false)
            #set($macro.initExpressionOverride = $initExpressionOverrides.get($param.type.canonicalName))
            #if($macro.initExpressionOverride)
                #if($StringUtils.equals($macro.initExpressionOverride.class.canonicalName, 'java.lang.String'))
                    ## This is a short form init expression override.
                    #set($param.initExpression = $macro.initExpressionOverride)
                    #set($param.shouldStoreInReference = false)
                    #set($param.shouldBeMocked = false)
                #else
                    ## This is a long form init expression override.
                    #set($param.initExpression = $macro.initExpressionOverride.initExpression)
                    #set($param.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
                    #set($param.shouldBeMocked = false)
                    #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
                #end
            #end
        #elseif($param.type.recognized && $param.type.shouldBeMocked)
            #useInlineMockForParam($param)
            #set($param.shouldStoreInReference = true)
        #else
            #set($param.shouldBeMocked = false)
        #end
        #if($isCreatingNewTest || !$dependencies.contains($param))
            #setTestClassNamesForParam($param)
        #end
    #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## updateDependenciesWithQuickSettings()
## Updates the $dependencies with the Quick Settings defined at the top of the file.
##----------------------------------------------------------------------------------------------------------------------
#macro(updateDependenciesWithQuickSettings)
    #foreach($dependency in $dependencies)
        #set($macro.initExpressionOverride = false)
        #set($macro.initExpressionOverride = $initExpressionOverrides.get($dependency.type.canonicalName))
        #if($macro.initExpressionOverride)
            #if($StringUtils.equals($macro.initExpressionOverride.class.canonicalName, 'java.lang.String'))
                ## This is a short form init expression override.
                #set($dependency.initExpression = $macro.initExpressionOverride)
                #set($dependency.shouldStoreInReference = false)
                #set($dependency.shouldBeMocked = false)
            #else
                ## This is a long form init expression override.
                #set($dependency.initExpression = $macro.initExpressionOverride.initExpression)
                #set($dependency.shouldStoreInReference = $macro.initExpressionOverride.shouldStoreInReference)
                #set($dependency.shouldBeMocked = false)
                #set($_ = $importLinesRequired.addAll($ListUtils.nullToEmpty($macro.initExpressionOverride.importsRequired)))
            #end
        #end
    #end
    #foreach($dependency in $possibleDependencies)
        #set($dependency.shouldBeMocked = false)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodParams()
## Updates dependency interaction method parameters to use appropriate values or matcher expressions.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodParams)
    #foreach($method in $sourceClass.allMethods)
    #foreach($di in $method.dependencyInteractions)
        #initializeDependencyInteractionMethodReturnType($di)
        ## Set the parameter init expressions to either values or matcher expressions.
        #if($di.method.shouldUseLastParam)
            #set($macro.params = $di.method.parameters)
        #else
            #set($macro.endIndexExclusive = $di.method.parameters.size() - 1)
            #set($macro.params = $di.method.parameters.subList(0, $macro.endIndexExclusive))
        #end
        #set($macro.hasCallableOrRunnableParam = $macro.params.containsAnyWith('type.canonicalName', 'java.util.concurrent.Callable','java.lang.Runnable'))
        #set($macro.hasParamRequiringMatcher = $macro.hasCallableOrRunnableParam || $macro.params.filterOut('type.primitive').containsAnyWith('type.overridesEquals', false))
    #foreach($param in $di.method.parameters)
        #set($param.shouldStoreInReference = false)
        ## Handle Callables and Runnables.
        #if($param.type.canonicalName == 'java.util.concurrent.Callable')
            #set($param.initExpression = 'any(Callable.class)')
            #set($param.defaultInitExpression = 'any(Callable.class)')
        #elseif($param.type.canonicalName == 'java.lang.Runnable')
            #set($param.initExpression = 'any(Runnable.class)')
            #set($param.defaultInitExpression = 'any(Runnable.class)')
        #else
            #if($param.type.primitive || $param.type.overridesEquals)
                #if($macro.hasParamRequiringMatcher)
                    #set($param.props.shouldUseEqMatcher = true)
                #end
            #else
                #set($param.initExpression = "any(${param.type.canonicalNameOrName}.class)")
                #set($param.defaultInitExpression = "any(${param.type.canonicalNameOrName}.class)")
            #end
        #end
    #end
    #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## initializeDependencyInteractionMethodReturnType($di)
## Sets the initExpression, testClassLocalFieldName and other properties in the $di.method.returnType.
## Param: $di the dependency interaction whose return type will be initialized.
##----------------------------------------------------------------------------------------------------------------------
#macro(initializeDependencyInteractionMethodReturnType $di)
    #if($di.method.returnType.dtoBean || !$di.method.returnType.initExpressionBeans.empty)
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
    #if($di.method.returnType.closeable)
        #set($di.method.returnType.shouldStoreInReference = true)
        #if($di.method.returnType.initExpression.equals('null'))
            #set($di.method.returnType.shouldBeMocked = true)
        #else
            #useInlineSpyForParam($di.method.returnType)
            #set($di.method.returnType.testClassLocalFieldName = "spy$StringUtils.capitalize($di.method.returnType.name)")
        #end
    #end
    #if($di.method.returnType.shouldBeMocked)
        #set($di.method.returnType.shouldStoreInReference = true)
        #useInlineMockForParam($di.method.returnType)
        #set($di.method.returnType.testClassLocalFieldName = "mock$StringUtils.capitalize($di.method.returnType.name)")
    #end
    #if($ClassUtils.removePackageQualifiers($di.method.returnType.initExpression).length() > 40
        || ($StringUtils.containsAny($di.method.returnType.initExpression, '[]', '[:]')
            && !$StringUtils.equalsAny($di.method.returnType.initExpression, '[]', '[:]')))
        #set($di.method.returnType.shouldStoreInReference = true)
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## setTestClassNamesForParam($param)
## Sets the Variable.testClassMemberName and Variable.testClassLocalFieldName properties on the given $param
## based on the Quick Settings.
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(setTestClassNamesForParam $param)
    #set($macro.baseName = $param.declaredNameWithoutPrefix)
    #if($param.containingMethod.setter && $param.containingMethod.targetField)
        #set($macro.baseName = $param.containingMethod.targetField.declaredNameWithoutPrefix)
    #end
    #if($param.shouldBeMocked)
        #if(${StringUtils.isNotEmpty($mockDependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${mockDependencyMemberNamePrefix}${StringUtils.capitalize(${macro.baseName})}")
        #elseif(${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${macro.baseName})}")
        #end
        #if(${StringUtils.isNotEmpty($mockParameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${mockParameterLocalFieldNamePrefix}${StringUtils.capitalize(${macro.baseName})}")
        #elseif(${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${macro.baseName})}")
        #end
    #else
        #if(${StringUtils.isNotEmpty($dependencyMemberNamePrefix)})
            #set($param.testClassMemberName = "${dependencyMemberNamePrefix}${StringUtils.capitalize(${macro.baseName})}")
        #end
        #if(${StringUtils.isNotEmpty($parameterLocalFieldNamePrefix)})
            #set($param.testClassLocalFieldName = "${parameterLocalFieldNamePrefix}${StringUtils.capitalize(${macro.baseName})}")
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineMockForParam($param)
## Updates the given parameter's initExpression to use an inline mock expression; e.g. mock(Foo.class).
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineMockForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "mock(${param.type.canonicalName}.class)")
        #set($param.defaultInitExpression = "mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.mock;"))
    #else
        #set($param.initExpression = "Mockito.mock(${param.type.canonicalName}.class)")
        #set($param.defaultInitExpression = "Mockito.mock(${param.type.canonicalName}.class)")
        #if($param.type.isAny('java.lang.Iterable'))
            #set($param.type.emptyInitExpression = "mock(${param.type.canonicalName}.class)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## useInlineSpyForParam($param)
## Updates the given parameter's initExpression to use an inline spy expression; e.g. spy(Foo.class).
## Param: $param the Variable to update
##----------------------------------------------------------------------------------------------------------------------
#macro(useInlineSpyForParam $param)
    #if($useStaticImportForInitMocks)
        #set($param.initExpression = "spy($param.initExpression)")
        #set($param.defaultInitExpression = "spy($param.defaultInitExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import static org.mockito.Mockito.spy;"))
    #else
        #set($param.initExpression = "Mockito.spy($param.initExpression)")
        #set($param.defaultInitExpression = "Mockito.spy($param.defaultInitExpression)")
        #if($param.type.emptyInitExpression)
            #set($param.type.emptyInitExpression = "Mockito.spy($param.type.emptyInitExpression)")
        #end
        #if($param.type.absentInitExpression && !$StringUtils.equals($param.type.absentInitExpression, 'null'))
            #set($param.type.absentInitExpression = "Mockito.spy($param.type.absentInitExpression)")
        #end
        #if($param.type.emptyIoInitExpression)
            #set($param.type.emptyIoInitExpression = "Mockito.spy($param.type.emptyIoInitExpression)")
        #end
        #if($param.type.brokenIoInitExpression)
            #set($param.type.brokenIoInitExpression = "Mockito.spy($param.type.brokenIoInitExpression)")
        #end
        #set($_ = $importLinesRequired.add("import org.mockito.Mockito;"))
    #end
    #set($param.shouldBeMocked = false)
    #set($param.shouldBeSpied = true)
#end

##----------------------------------------------------------------------------------------------------------------------
## askUserToConfirmSettingsIfNeeded()
## Shows a dialog asking the user to confirm the provided rendering options. The dialog is only shown if the template
## was invoked with $shouldAskToConfirmSettings = true.
##
## The template is invoked with $shouldAskToConfirmSettings = true in the following cases.
## 1. The user invokes the "Generate Test Confirm Options" menu item. In this case Squaretest shows a dialog box asking
##    the user to confirm the provided options.
## 2. The user is adding tests to an existing test class. In this case the API is invoked, and Squaretest answers the
##    API call with the decisions made in the existing test class.
##----------------------------------------------------------------------------------------------------------------------
#macro(askUserToConfirmSettingsIfNeeded)
    #if($shouldAskToConfirmSettings)
        ## Show the dialog to ask the user to confirm the provided settings.
        #set($userProvidedSettings =
            $UiUtils.askUserToConfirmSettingsV2({
                'dependencies' : $dependencies,
                'possibleDependencies' : $possibleDependencies,
                'canCreateSourceClassInEachTestMethod' : $canCreateSourceClassInEachTestMethod,
                'shouldCreateSourceClassInEachTestMethod' : $shouldCreateSourceClassInEachTestMethod,
                'methodsThatCanBeTested' : $methodsThatCanBeTested,
                'testClassMemberName' : $sourceClass.testClassMemberName,
                'testClassLocalFieldName' : $sourceClass.testClassLocalFieldName
        }))
        #set($dependencies = $userProvidedSettings.get('dependencies'))
        #set($possibleDependencies = $userProvidedSettings.get('possibleDependencies'))
        #set($shouldCreateSourceClassInEachTestMethod = $userProvidedSettings.get('shouldCreateSourceClassInEachTestMethod'))
        #set($methodsThatCanBeTested = $userProvidedSettings.get('methodsThatCanBeTested'))
        #set($sourceClass.testClassMemberName = $userProvidedSettings.get('testClassMemberName'))
        #set($sourceClass.testClassLocalFieldName = $userProvidedSettings.get('testClassLocalFieldName'))
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## updateDependenciesWithUserChoices()
## Updates the $dependencies based on the user selection in the dialog shown in the
## askUserToConfirmSettingsIfNeeded(..) call
##----------------------------------------------------------------------------------------------------------------------
#macro(updateDependenciesWithUserChoices)
    #set($_ = $dependencies.addAll($possibleDependencies.filter('shouldBeMocked')))
    #if($isCreatingNewTest)
        #foreach($dependency in $dependencies)
            #if($dependency.shouldBeMocked || (!$initExpressionOverrides.containsKey($dependency.type.canonicalNameOrName) && $ClassUtils.hasBeanWithUsedProperty($dependency.type)))
                #set($dependency.shouldStoreInReference = true)
                #setTestClassNamesForParam($dependency)
                #foreach($beanType in $dependency.type.initExpressionBeans)
                    #set($beanType.shouldOnlySetUsedProperties = true)
                #end
            #else
                #set($dependency.shouldStoreInReference = false)
            #end
        #end
        ## Ensure we don't have name conflicts between the dependencies stored in member fields.
        #foreach($dependency in $dependencies)
            #if($dependency.shouldStoreInReference && ($dependency.shouldBeMocked || !$shouldCreateSourceClassInEachTestMethod))
                #set($_ = $CodeStyleUtils.updateMemberFieldNameWithClassScope($dependency))
            #end
        #end
    #else
        ## We are generating tests to add to an existing test class. Use inline mocks for dependencies that require
        ## them. This is needed to handle the case where the existing test sets dependencies with code like:
        ## fooProviderUnderTest.fooService = mock(Foo.class).
        #foreach($dependency in $dependencies)
            #if($dependency.shouldBeMocked && !$dependency.shouldStoreInReference)
                #useInlineMockForParam($dependency)
            #end
        #end
    #end
#end

##----------------------------------------------------------------------------------------------------------------------
## computeFinalRenderingParameters()
## Determines the final rendering parameters after the user has confirmed the rendering options via the
## askUserToConfirmSettingsIfNeeded(..) call.
## This macro sets the following variables.
##   $mockMembers                   contains dependencies that should be mocked and stored in test class members.
##   $setterMethodsToCall           The setter methods that should be used to initialize the source class.
##   $packageLocalFieldsToSet       The package local fields that should be set to initialize the source class.
##   $packageLocalFieldsWithInlineMocks subset of $packageLocalFieldsToSet that contains package local fields that are
##                                  set to inline mocks.
##   $fieldsToSetWithReflection     Source class members that should be set via reflection to initialize the source
##                                  class.
##   $fieldsThatCannotBeSet         Source class members that Squaretest does not know how to set.
##   $shouldUseInjectMocks          boolean indicating whether or not @InjectMocks should be used to provide
##                                  dependencies to the instance of the source class.
##   $shouldRenderSourceClassMember boolean indicating whether or not an instance of the source class should be
##                                  created and stored in a member of the test class.
##   $shouldRenderMockitoCloseable  boolean indicating whether a mockitoCloseable should be rendered.
##   $shouldRenderSetupMethod       boolean indicating whether a setup method should be rendered.
##   $shouldRenderTearDownMethod    boolean indicating whether a tear down method should be rendered.
##----------------------------------------------------------------------------------------------------------------------
#macro(computeFinalRenderingParameters)
    #set($mockMembers = $FluentList.of())
    #set($setterMethodsToCall = $FluentList.of())
    #set($packageLocalFieldsToSet = $FluentList.of())
    #set($packageLocalFieldsWithInlineMocks = $FluentList.of())
    #set($fieldsToSetWithReflection = $FluentList.of())
    #set($fieldsThatCannotBeSet = $FluentList.of())
    #set($shouldUseInjectMocks = false)
    #set($shouldRenderSourceClassMember = false)
    #set($shouldRenderMockitoCloseable = false)
    #set($shouldRenderSetupMethod = false)
    #set($shouldRenderTearDownMethod = false)

    ## Select the methods to test.
    #set($methodsToTest = $methodsThatCanBeTested.filter('shouldTest'))
    #set($methodsToTest = $ClassUtils.updateOverloadSuffixes($methodsToTest))
    #if($methodsToTest.filterOut('static').empty && !$methodsToTest.empty)
        ## We are only testing static methods.
        #break($macro)
    #end
    #set($macro.isZeroArgConstructor = $sourceClassConstructor && $sourceClassConstructor.parameters.empty)
    #set($shouldUseInjectMocks = $macro.isZeroArgConstructor && !$dependencies.filter('member').filter('private').filter('shouldBeMocked').empty)
    #foreach($dependency in $dependencies)
        #if($dependency.containingMethod.constructor)
            #if($dependency.shouldBeMocked)
                #set($_ = $mockMembers.add($dependency))
            #end
        #elseif($dependency.containingMethod.setter)
            #if($dependency.shouldBeMocked)
                #set($_ = $mockMembers.add($dependency))
            #end
            #set($_ = $setterMethodsToCall.add($dependency.containingMethod))
        #elseif($dependency.member)
            #if($dependency.final)
                #if($dependency.shouldBeMocked)
                    #set($_ = $mockMembers.add($dependency))
                #end
                #set($_ = $fieldsThatCannotBeSet.add($dependency))
            #elseif($dependency.private)
                #if($dependency.shouldBeMocked)
                    #set($_ = $mockMembers.add($dependency))
                    #if(!$shouldUseInjectMocks)
                        #if($hasReflectionTestUtils)
                            #set($_ = $fieldsToSetWithReflection.add($dependency))
                        #else
                            #set($_ = $fieldsThatCannotBeSet.add($dependency))
                        #end
                    #end
                #else
                    #if($hasReflectionTestUtils)
                        #set($_ = $fieldsToSetWithReflection.add($dependency))
                    #else
                        #set($_ = $fieldsThatCannotBeSet.add($dependency))
                    #end
                #end
            #else
               #if($dependency.shouldBeMocked)
                   #if($dependency.shouldStoreInReference)
                       #set($_ = $mockMembers.add($dependency))
                   #else
                       #set($_ = $packageLocalFieldsWithInlineMocks.add($dependency))
                   #end
               #end
               #set($_ = $packageLocalFieldsToSet.add($dependency))
            #end
        #end
    #end
    #set($shouldRenderSourceClassMember = !$androidActivity && !$sourceClass.enum && !$shouldCreateSourceClassInEachTestMethod)
    #set($shouldRenderMockitoCloseable = !$mockMembers.empty && $hasOpenMocksMethod)
    ## Determine if we need to render the setUp(..) method.
    #if(!$mockMembers.empty)
        #set($shouldRenderSetupMethod = true)
    #elseif($shouldRenderSourceClassMember)
        #if(!$shouldUseInjectMocks)
            #set($shouldRenderSetupMethod = true)
        #end
        #if(!$fieldsToSetWithReflection.empty || !$setterMethodsToCall.empty || !$packageLocalFieldsToSet.empty || !$fieldsThatCannotBeSet.empty)
            #set($shouldRenderSetupMethod = true)
        #end
    #end

    ## Determine if we need to render a tearDown(..) method.
    #set($shouldRenderTearDownMethod = $shouldRenderMockitoCloseable)
    #set($_ = $TestInfo.updateDependencies($dependencies))
#end

## Declare global variables set by initializeTemplateDataModel() to enable partial code completion in the Velocity
## editor bundled with the IntelliJ IDEA Ultimate Edition.

## Variables Used In Test Class Setup Code:
#* @vtlvariable name="dependencies" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="mockMembers" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="shouldRenderSourceClassMember" type="boolean" *#
#* @vtlvariable name="shouldUseInjectMocks" type="boolean" *#
#* @vtlvariable name="shouldRenderMockitoCloseable" type="boolean" *#
#* @vtlvariable name="shouldRenderSetupMethod" type="boolean" *#
#* @vtlvariable name="shouldRenderTearDownMethod" type="boolean" *#
#* @vtlvariable name="hasOpenMocksMethod" type="boolean" *#
#* @vtlvariable name="initMocksMethodName" type="java.lang.String" *#
#* @vtlvariable name="hasReflectionTestUtils" type="boolean" *#
#* @vtlvariable name="hasAssertThrows" type="boolean" *#
#* @vtlvariable name="androidActivity" type="boolean" *#
#* @vtlvariable name="hasActivityScenario" type="boolean" *#
#* @vtlvariable name="shouldUseAndroidRule" type="boolean" *#
#* @vtlvariable name="methodsToTest" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#

## Variables Used In Source Class Initialization:
#* @vtlvariable name="shouldCreateSourceClassInEachTestMethod" type="boolean" *#
#* @vtlvariable name="sourceClassConstructor" type="com.squaretest.template.api.Api.Constructor" *#
#* @vtlvariable name="setterMethodsToCall" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="packageLocalFieldsToSet" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.ClassMember>" *#
#* @vtlvariable name="packageLocalFieldsWithInlineMocks" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.ClassMember>" *#
#* @vtlvariable name="fieldsToSetWithReflection" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.ClassMember>" *#
#* @vtlvariable name="fieldsThatCannotBeSet" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.ClassMember>" *#

## Mockito Variables Set Based On $shouldUseMockitoBdd:
#* @vtlvariable name="doAnswer" type="java.lang.String" *#
#* @vtlvariable name="doReturn" type="java.lang.String" *#
#* @vtlvariable name="thenReturn" type="java.lang.String" *#
#* @vtlvariable name="when" type="java.lang.String" *#
#* @vtlvariable name="doThrow" type="java.lang.String" *#
#* @vtlvariable name="thenThrow" type="java.lang.String" *#

## Variables Used Internally In initializeTemplateDataModel(..)
#* @vtlvariable name="possibleDependencies" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Variable>" *#
#* @vtlvariable name="canCreateSourceClassInEachTestMethod" type="boolean" *#
#* @vtlvariable name="methodsThatCanBeTested" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#

## Parameter Names Used In Various Macros.
#* @vtlvariable name="testInfo" type="com.squaretest.template.api.Api.TestInfo" *#
#* @vtlvariable name="exceptionToThrow" type="com.squaretest.template.api.Api.Exception" *#
#* @vtlvariable name="dependency" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="methods" type="com.squaretest.template.api.Api.FluentList<com.squaretest.template.api.Api.Method>" *#
#* @vtlvariable name="method" type="com.squaretest.template.api.Api.Method" *#
#* @vtlvariable name="param" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="typeOrVariable" type="com.squaretest.template.api.Api.Variable" *#
#* @vtlvariable name="type" type="com.squaretest.template.api.Api.Type" *#
#* @vtlvariable name="field" type="com.squaretest.template.api.Api.ClassMember" *#
#* @vtlvariable name="di" type="com.squaretest.template.api.Api.DependencyInteraction" *#
#* @vtlvariable name="testCaseSuffix" type="java.lang.String" *#
#* @vtlvariable name="beanSourceClass" type="com.squaretest.template.api.Api.SourceClass" *#
#* @vtlvariable name="shouldUseEmptyIo" type="boolean" *#
#* @vtlvariable name="shouldUseBrokenIo" type="boolean" *#
#* @vtlvariable name="recursiveCounter" type="int" *#
#* @vtlvariable name="numberOfSettersCalled" type="org.apache.commons.lang3.mutable.MutableInt" *#
#* @vtlvariable name="canonicalNamesInCallStack" type="java.util.Map<java.lang.String, java.lang.Boolean>" *#
#* @vtlvariable name="methodsAlreadyTested" type="java.util.Map<com.squaretest.template.api.Api.Method, java.lang.Boolean>" *#
#* @vtlvariable name="getterSetterTestNamesUsed" type="java.util.Map<java.lang.String, java.lang.Integer>" *#