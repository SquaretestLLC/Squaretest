/*
 * Copyright 2026 Squaretest LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squaretest.generation;

import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiCompiledElement;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiField;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiParameter;
import com.intellij.psi.PsiType;
import com.intellij.psi.util.PsiUtil;
import com.squaretest.generation.defaulttypes.JavaNames;
import com.squaretest.generation.defaulttypes.SQAnnotationUtil;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.Nullable;

public class CompiledUtils {
    private CompiledUtils() {
    }

    public static PsiElement getElementWithSourceCode(PsiElement element) {
        if(element instanceof PsiMethod) {
            return getMethodWithSourceCode((PsiMethod) element);
        }
        return getItemWithSourceCode(PsiElement.class, element);
    }

    public static PsiClass getClassWithSourceCode(PsiClass psiClass) {
        return getItemWithSourceCode(PsiClass.class, psiClass);
    }

    public static PsiMethod getMethodWithSourceCode(final PsiMethod method) {
        if(method == null) {
            return null;
        }
        if(!(method instanceof PsiCompiledElement)) {
            return method;
        }
        final PsiElement target = method.getNavigationElement();
        if(target instanceof PsiMethod) {
            return (PsiMethod) target;
        }
        // The Lombok plugin sets the navigation element to different places. That is likely the case here.
        // First check to see if the compiled method is a lombok builder method for which the sources are available.
        final PsiMethod lombokBuilderMethod = tryGetLombokBuilderMethod(method);
        if(lombokBuilderMethod != null) {
            return lombokBuilderMethod;
        }
        // Check to see if the target is a PsiField. In that case, we have a lombok getter or setter method.
        // Scan the field's containing class for a method that matches our method's signature. That is the source
        // method. The source method may not actually be in the source code. It could be a Lombok Light method
        // (method generated by the Lomobk plugin). In this case, we should return the light method.
        if(target instanceof PsiField) {
            final PsiClass fieldContainingClass = ((PsiField) target).getContainingClass();
            if(fieldContainingClass == null) {
                return method;
            }
            final PsiMethod sourceMethod = findMethodBySignature(fieldContainingClass, method);
            if(sourceMethod != null) {
                return sourceMethod;
            } else {
                return method;
            }
        }
        // If the nav target is an annotation and the method is a constructor, assume we have a lombok-generated
        // constructor. Find the method's "containing class with source code", then scan it for a method that matches
        // our signature. That is the source method.
        if(target instanceof PsiAnnotation && method.isConstructor()) {
            final PsiClass methodContainingClass = getClassWithSourceCode(method.getContainingClass());
            if(methodContainingClass == null) {
                return method;
            }
            final PsiMethod sourceMethod = findMethodBySignature(methodContainingClass, method);
            if(sourceMethod != null) {
                return sourceMethod;
            } else {
                return method;
            }
        }
        return method;
    }

    @Nullable
    private static PsiMethod findMethodBySignature(final PsiClass fieldContainingClass, final PsiMethod searchMethod) {
        PsiMethod matchingMethod = fieldContainingClass.findMethodBySignature(searchMethod, false);
        if(matchingMethod != null) {
            return matchingMethod;
        }
        final PsiParameter[] searchMethodParams = searchMethod.getParameterList().getParameters();
        for(final PsiMethod psiMethod : fieldContainingClass.findMethodsByName(searchMethod.getName(), false)) {
            final PsiParameter[] psiMethodParams = psiMethod.getParameterList().getParameters();
            if(paramsMatch(searchMethodParams, psiMethodParams)) {
                return psiMethod;
            }
        }

        return null;
    }

    private static boolean paramsMatch(final PsiParameter[] searchMethodParams, final PsiParameter[] psiMethodParams) {
        if(searchMethodParams.length != psiMethodParams.length) {
            return false;
        }
        for(int i = 0; i < searchMethodParams.length; i++) {
            final PsiType searchParamType = searchMethodParams[i].getType();
            final PsiType methodParamType = psiMethodParams[i].getType();
            if(!StringUtils.equals(searchParamType.getCanonicalText(), methodParamType.getCanonicalText())) {
                return false;
            }
        }
        return true;
    }

    private static PsiMethod tryGetLombokBuilderMethod(final PsiMethod method) {
        // Determine if we're a compiled lombok builder method, then find and return the source method if available.
        // The source method is the PsiLight method created by the Lombok plugin and added to the
        // source (non-compiled) class.
        final PsiElement navElement = method.getNavigationElement();
        if(!(navElement instanceof final PsiField targetField)) {
            return null;
        }
        final PsiClass targetFieldClass = targetField.getContainingClass();
        if(targetFieldClass == null) {
            return null;
        }
        final PsiClass methodContainingClass = method.getContainingClass();
        if(methodContainingClass == null) {
            return null;
        }
        final PsiElement containingClassNavElement = methodContainingClass.getNavigationElement();
        if(!(containingClassNavElement instanceof final PsiAnnotation annotation)) {
            return null;
        }
        if(!StringUtils.equalsAny(annotation.getQualifiedName(), JavaNames.AllLombokBuilders)) {
            return null;
        }
        final String builderMethodName = SQAnnotationUtil.getStringAnnotationValue(annotation, "builderMethodName", "builder");
        if(builderMethodName == null) {
            return null;
        }
        final PsiMethod[] builderMethods = targetFieldClass.findMethodsByName(builderMethodName, false);
        if(builderMethods.length != 1) {
            return null;
        }
        final PsiMethod builderMethod = builderMethods[0];
        final PsiClass builderClass = PsiUtil.resolveClassInType(builderMethod.getReturnType());
        if(builderClass == null) {
            return null;
        }
        return findMethodBySignature(builderClass, method);
    }

    public static PsiField getFieldWithSourceCode(PsiField field) {
        return getItemWithSourceCode(PsiField.class, field);
    }

    private static <T> T getItemWithSourceCode(Class<T> theClass, final T theObj) {
        if(theObj instanceof final PsiCompiledElement compiledField) {
            final PsiElement sourceItem = compiledField.getNavigationElement();
            if(theClass.isInstance(sourceItem)) {
                return theClass.cast(sourceItem);
            }
        }
        return theObj;
    }
}
