/*
 * Copyright 2026 Squaretest LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.squaretest.multipletests;

import com.intellij.icons.AllIcons;
import com.intellij.ide.fileTemplates.FileTemplate;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.ComboBox;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.psi.PsiMethod;
import com.intellij.ui.BooleanTableCellRenderer;
import com.intellij.ui.ColoredTableCellRenderer;
import com.intellij.ui.SimpleTextAttributes;
import com.intellij.ui.components.JBScrollPane;
import com.intellij.ui.table.JBTable;
import com.squaretest.TemplateProvider;
import com.squaretest.confirmsettings.v2.BooleanHeaderRenderer;
import com.squaretest.generation.errorui.RenderingFailedDialog;
import com.squaretest.generation.filetemplateutil.TemplateRenderingException;
import com.squaretest.settings.displaywrappers.DisplayTemplate;
import com.squaretest.settings.displaywrappers.TemplateComboBoxModel;
import com.squaretest.settings.displaywrappers.TemplateComboBoxRendererWrapper;
import com.squaretest.settings.store.Template;
import com.squaretest.utils.MathUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.*;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;

import static com.squaretest.confirmsettings.v2.SelectMocksTable.setupCheckboxColumn;
import static com.squaretest.settings.TemplateConfigComponent.SelectTemplateMaxRows;
import static com.squaretest.settings.TemplateConfigComponent.hasChangedFromPreviousValue;

public class SelectMethodsDialog extends DialogWrapper {

    @NotNull
    private final Project project;
    @NotNull
    private final TestMethodGenerator testMethodGenerator;
    @NotNull
    private final Template defaultTemplate;
    @NotNull
    private final TemplateProvider templateProvider;

    private JPanel rootPanel;
    private JComboBox<DisplayTemplate> selectTemplate;
    private JTable methodsTable;
    private JScrollPane spSelectMethods;
    private boolean wasCancelled = false;
    private BooleanHeaderRenderer cbSelectAll;

    public SelectMethodsDialog(
            @NotNull final Project project, @NotNull final TestMethodGenerator testMethodGenerator,
            @NotNull final Template defaultTemplate, @NotNull final TemplateProvider templateProvider) {
        super(project);
        this.project = project;
        this.testMethodGenerator = testMethodGenerator;
        this.defaultTemplate = defaultTemplate;
        this.templateProvider = templateProvider;
        // createUIComponents() is called here by the autogenerated bytecode.
        init();
        setTitle("Select Test Methods To Create");
    }

    @Override
    public void doCancelAction() {
        super.doCancelAction();
        this.wasCancelled = true;
    }

    private void createUIComponents() {
        spSelectMethods = new JBScrollPane();
        final MyTableModel defaultTableModel = new MyTableModel(Collections.emptyList());
        methodsTable = new JBTable(defaultTableModel);
        TableColumnModel columnModel = methodsTable.getColumnModel();
        columnModel.getColumn(MyTableModel.DISPLAY_NAME_COLUMN).setCellRenderer(new MyTableRenderer(methodsTable));
        TableColumn checkBoxColumn = columnModel.getColumn(MyTableModel.CHECKED_COLUMN);
        setupCheckboxColumn(methodsTable, MyTableModel.CHECKED_COLUMN);
        checkBoxColumn.setCellRenderer(new BooleanTableCellRenderer());
        // methodsTable.setPreferredScrollableViewportSize(new Dimension(600, methodsTable.getRowHeight() * 12));
        methodsTable.setShowGrid(false);
        methodsTable.setIntercellSpacing(new Dimension(0, 0));
        selectTemplate = new ComboBox<>(createModel(templateProvider.getTemplates(defaultTemplate.getTemplateLanguage()), defaultTemplate));
        selectTemplate.setMaximumRowCount(SelectTemplateMaxRows);
        selectTemplate.setRenderer(new TemplateComboBoxRendererWrapper(selectTemplate.getRenderer()));
        selectTemplate.addActionListener(e -> onSelectedTemplateChanged());
        // Configure select all checkbox.
        final JTableHeader tableHeader = methodsTable.getTableHeader();
        tableHeader.setResizingAllowed(false);
        tableHeader.setReorderingAllowed(false);
        cbSelectAll = new BooleanHeaderRenderer();
        cbSelectAll.setForeground(tableHeader.getForeground());
        cbSelectAll.setBackground(tableHeader.getBackground());
        checkBoxColumn.setHeaderRenderer(cbSelectAll);
        tableHeader.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(final MouseEvent e) {
                if(e.getButton() == 1) {
                    int columnAtPoint = methodsTable.columnAtPoint(e.getPoint());
                    if(columnAtPoint == MyTableModel.CHECKED_COLUMN && cbSelectAll.isEnabled()) {
                        final boolean currentState = cbSelectAll.isSelected();
                        final boolean newState = !currentState;
                        boolean wasChanged = false;
                        final MyTableModel tableModel = (MyTableModel) methodsTable.getModel();
                        for(final WrappedMethod method : tableModel.getTestMethods()) {
                            if(method.isSelected() != newState) {
                                wasChanged = true;
                                method.setSelected(newState);
                            }
                        }
                        if(wasChanged) {
                            tableModel.fireTableDataChanged();
                        }
                        cbSelectAll.setSelected(newState);
                        tableHeader.repaint();
                        return;
                    }
                }
                super.mouseClicked(e);
            }
        });
    }

    private void onSelectedTemplateChanged() {
        if(!hasChangedFromPreviousValue(selectTemplate)) {
            return;
        }
        final DisplayTemplate displayTemplate = (DisplayTemplate) this.selectTemplate.getSelectedItem();
        if(displayTemplate == null) {
            return;
        }

        // Run the template to create the test methods.
        final Template selectedTemplate = displayTemplate.getTemplate();
        List<PsiMethod> generatedMethods;
        try {
            generatedMethods = testMethodGenerator.runTemplateAndReturnTestMethods(templateProvider.getFileTemplate(selectedTemplate));
            // Update the data model.
            final List<WrappedMethod> wrappedMethods = wrap(generatedMethods);
            wrappedMethods.sort(Comparator.comparing(WrappedMethod::getSortName));
            ((MyTableModel) methodsTable.getModel()).setTestMethods(wrappedMethods);
            final int longestMethodSize = getLongestMethodDisplaySize(wrappedMethods);
            final int width = MathUtils.clamp(longestMethodSize + 80, 300, 600);
            methodsTable.setPreferredScrollableViewportSize(new Dimension(width, methodsTable.getRowHeight() * MathUtils.clamp(wrappedMethods.size(), 3, JBTable.PREFERRED_SCROLLABLE_VIEWPORT_HEIGHT_IN_ROWS)));
            cbSelectAll.setEnabled(!wrappedMethods.isEmpty());
        } catch(final TemplateRenderingException e) {
            ((MyTableModel) methodsTable.getModel()).setTestMethods(Collections.emptyList());
            showRenderingFailureDialog(e);
        }
    }

    private int getLongestMethodDisplaySize(final List<WrappedMethod> wrappedMethods) {
        final JLabel jLabel = new JLabel();
        final FontMetrics fontMetrics = jLabel.getFontMetrics(jLabel.getFont());
        return wrappedMethods.stream().max(Comparator.comparing(x -> fontMetrics.stringWidth(x.getDisplayName()))).map(x -> fontMetrics.stringWidth(x.getDisplayName())).orElse(0);
    }

    private void showRenderingFailureDialog(final TemplateRenderingException e) {
        final RenderingFailedDialog dialog = new RenderingFailedDialog(project, e);
        dialog.showAndGet();
    }

    private TemplateComboBoxModel createModel(final List<Template> templates, final Template defaultTemplate) {
        final List<DisplayTemplate> displayTemplates = new ArrayList<>(templates.size());
        DisplayTemplate defaultDisplayTemplate = null;
        for(final Template template : templates) {
            final DisplayTemplate displayTemplate = DisplayTemplate.fromTemplate(template);
            if(defaultTemplate.equals(template)) {
                defaultDisplayTemplate = displayTemplate;
            }
            displayTemplates.add(displayTemplate);
        }
        final TemplateComboBoxModel model = new TemplateComboBoxModel(displayTemplates);
        model.setSelectedItem(defaultDisplayTemplate);
        return model;
    }

    public SelectMethodsResult getSelectMethodsResult() {
        final List<WrappedMethod> methods = ((MyTableModel) methodsTable.getModel()).getTestMethods().stream().filter(WrappedMethod::isSelected).collect(Collectors.toList());
        final DisplayTemplate displayTemplate = (DisplayTemplate) this.selectTemplate.getSelectedItem();
        final FileTemplate template = templateProvider.getFileTemplate(displayTemplate.getTemplate());
        return new SelectMethodsResult(unwrap(methods), wasCancelled, template);
    }

    @Nullable
    @Override
    protected JComponent createCenterPanel() {
        onSelectedTemplateChanged();
        return rootPanel;
    }

    protected static class MyTableModel extends AbstractTableModel {
        static final int CHECKED_COLUMN = 0;
        static final int DISPLAY_NAME_COLUMN = 1;
        static final String DISPLAY_NAME_COLUMN_HEADER = "Select Test Methods To Create";
        private List<WrappedMethod> testMethods;

        public MyTableModel(final List<WrappedMethod> testMethods) {
            this.testMethods = testMethods;
        }

        public void setTestMethods(final List<WrappedMethod> newData) {
            this.testMethods = newData;
            fireTableDataChanged();
        }

        public List<WrappedMethod> getTestMethods() {
            return testMethods;
        }

        @Override
        public int getColumnCount() {
            return 2;
        }

        @Override
        public int getRowCount() {
            return this.testMethods.size();
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            if(columnIndex == CHECKED_COLUMN) {
                return Boolean.class;
            }
            return super.getColumnClass(columnIndex);
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            final WrappedMethod memberInfo = testMethods.get(rowIndex);
            return switch(columnIndex) {
                case CHECKED_COLUMN -> memberInfo.isSelected();
                case DISPLAY_NAME_COLUMN -> memberInfo.getDisplayName();
                default -> throw new RuntimeException("Incorrect column index");
            };
        }

        @Override
        public String getColumnName(int column) {
            return switch(column) {
                case CHECKED_COLUMN -> " ";
                case DISPLAY_NAME_COLUMN -> DISPLAY_NAME_COLUMN_HEADER;
                default -> throw new RuntimeException("Incorrect column index");
            };
        }

        @Override
        public boolean isCellEditable(int rowIndex, int columnIndex) {
            return columnIndex == CHECKED_COLUMN;
        }


        @Override
        public void setValueAt(final Object aValue, final int rowIndex, final int columnIndex) {
            if(columnIndex == CHECKED_COLUMN) {
                testMethods.get(rowIndex).setSelected((Boolean) aValue);
            }
        }
    }

    private static class MyTableRenderer extends ColoredTableCellRenderer {

        private final JTable myTable;

        private MyTableRenderer(final JTable myTable) {
            this.myTable = myTable;
        }

        @Override
        public void customizeCellRenderer(
                @NotNull JTable table, final Object value, boolean isSelected, boolean hasFocus, final int row,
                final int column) {

            final int modelColumn = myTable.convertColumnIndexToModel(column);

            if(modelColumn == MyTableModel.DISPLAY_NAME_COLUMN) {
                setIcon(AllIcons.Nodes.Method);
            } else {
                setIcon(null);
            }
            setIconOpaque(false);
            setOpaque(false);

            if(value == null) {
                return;
            }
            append((String) value, new SimpleTextAttributes(SimpleTextAttributes.STYLE_PLAIN, null));
        }
    }

    private List<WrappedMethod> wrap(final List<PsiMethod> methods) {
        final List<WrappedMethod> wrappedMethods = new ArrayList<>(methods.size());
        for(final PsiMethod method : methods) {
            wrappedMethods.add(new WrappedMethod(method));
        }
        return wrappedMethods;
    }

    private List<PsiMethod> unwrap(final List<WrappedMethod> wrappedMethods) {
        final List<PsiMethod> methods = new ArrayList<>(wrappedMethods.size());
        for(final WrappedMethod wrappedMethod : wrappedMethods) {
            methods.add(wrappedMethod.getPsiMethod());
        }
        return methods;
    }
}
